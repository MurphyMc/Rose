module Rose

$define Scope RoseObject

class Cmd
  PROPERTIES
    t : Token

  METHODS
    method add_to( statements:CmdStatementList )
      statements.add( this )

    method eval( scope:Scope )->Value
      throw t.error( "[INTERNAL] $.eval() is not implemented." (type_name) )

    method eval_assignment( scope:Scope, new_value:Cmd )->Value
      throw t.error( "Invalid assignment." )

    method eval_adjust( scope:Scope, delta:Int32 )->Value
      throw t.error( "Invalid target for increment/decrement. ($)" (type_name) )

#{
    method call_prior( scope:Scope )->Cmd
      throw t.error( "Illegal target - 'prior' can only be used to call overridden methods." )

    method cast_to( target_type:Type, scope:Scope, &allow_implicit_narrowing, &is_conversion )->Cmd
      return cast_to( require_type, target_type, scope, allow_implicit_narrowing, is_conversion )

    method cast_to( this_type:Type, target_type:Type, scope:Scope, &allow_implicit_narrowing, &is_conversion )->Cmd
      if (this_type is target_type) return this

      this_type.organize(scope)
      target_type.organize(scope)

      if (not is_conversion)
        if (this_type.instance_of(target_type) or (target_type.instance_of(this_type) and allow_implicit_narrowing))
          return CmdCastToType( t, this, target_type )
        endIf
      endIf

      if (this_type.is_primitive and target_type.is_primitive)
        if (not (this_type is Program.type_Logical or target_type is Program.type_Logical))
          return CmdCastToType( t, this, target_type )
        endIf
      endIf

      local m_name = "to_" + target_type.name
      if (this_type.has_method_named(m_name))
        return scope.resolve_call( this_type, CmdAccess(t,this,m_name), true )
      endIf

      if (target_type.find_method( "init($)"(this_type.name) )...
          or target_type.find_global_method( "create($)"(this_type.name)))
        return CmdAccess( t, target_type.name, CmdArgs(this) ).resolve( scope )
      endIf

      if (is_conversion)
        if (this_type.instance_of(target_type) or (target_type.instance_of(this_type) and allow_implicit_narrowing))
          return CmdCastToType( t, this, target_type )
        endIf
      endIf

      if (target_type is Program.type_Logical) return CmdLogicalize(t,this)

      if (target_type.is_optional)
        if (this_type is target_type.element_type)
          return CmdAccess( t, "$?"(this_type.name), CmdArgs(this) )
        elseIf (this_type.instance_of(target_type.element_type))
          local as_element_type = cast_to( this_type, target_type.element_type, scope ).resolve( scope )
          return as_element_type.cast_to( target_type, scope, allow_implicit_narrowing, is_conversion )
        elseIf (this_type is Program.type_null)
          return CmdAccess( t, "$?"(this_type.name), CmdArgs() )
        elseIf (this_type.is_primitive)
          return cast_to( target_type.element_type, scope, allow_implicit_narrowing ).resolve(scope).cast_to( target_type, scope, allow_implicit_narrowing )
        endIf
      endIf

      if (target_type.instance_of(this_type))
        throw t.error( 'No $.to->$() conversion method exists - use "<expression> as $" instead.' (this_type,target_type,target_type) )
      endIf

      if (this_type.is_aspect) return cast_to( Program.type_Object, target_type, scope, allow_implicit_narrowing, is_conversion )

      throw t.error( "Type $ cannot be cast to required type $." (this_type,target_type) )
}#

    method clone( other:Cmd, clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (other) return other.cloned( clone_args, new_t )
      return null

    method clone( args:CmdArgs, clone_args=null:CloneArgs, new_t=null:Token )->CmdArgs
      if (args) return args.cloned( clone_args, new_t )
      return null

    method clone( statements:CmdStatementList, clone_args=null:CloneArgs, new_t=null:Token )->CmdStatementList
      if (statements) return statements.cloned( clone_args, new_t )
      return null

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      throw t.error( "[INTERNAL] $.cloned() is not implemented." (type_name) )

#{
    method combine_literal_operands( common_type:Type )->Cmd
      return this
}#
#{
    method exit_scope( scope:Scope )
}#
    method is_global->Logical
      return false

    method is_scoped_read_access->Logical
      # Access, ReadLocal, ReadProperty, CallX.
      return false

    method is_literal->Logical
      return false

    method is_literal_number->Logical
      return false

#{
    method require_type_context
      if (type) throw t.error( ''Type name expected, e.g. "$.".'' (type) )
      else       throw t.error( ''Type name expected.'' )
}#

#{
    method require_integer->Cmd
      local _type = type
      if (_type is null or _type is not Program.type_Int32)
        throw t.error( "Int32 value expected." )
      endIf
      return this

    method require_logical( scope:Scope )->Cmd
      if (require_type is not Program.type_Logical)
        return CmdLogicalize( t, this ).resolve( scope )
      endIf
      return this
}#
    method require_value->Cmd
#      require_type
      return this

    method requires_semicolon->Logical
      return true

    method resolve( scope:Scope )->Cmd
      throw t.error( "[INTERNAL] $.resolve() is not defined." (type_name) )
      return this

#{
    method resolve_assignment( scope:Scope, new_value:Cmd )->Cmd
      throw t.error( "Invalid assignment." )

    method resolve_adjust( scope:Scope, delta:Int32 )->Cmd
      throw t.error( "Invalid target for increment/decrement. ($)" (type_name) )

    method resolve_modify_and_assign( scope:Scope, op:TokenType, new_value:Cmd )->Cmd
      throw t.error( "Invalid assignment." )
}#
    method to->Byte
      return this->Int32->Byte

    method to->Int32
      return 0

    method to->Logical
      return false

endClass

#------------------------------------------------------------------------------
# StatementList
#------------------------------------------------------------------------------
class CmdStatementList : Cmd[]
  GLOBAL PROPERTIES
    current : CmdStatementList

  METHODS
    method init
      init( 0 )

    method init( initial_capacity:Int32)
      prior.init( initial_capacity )

    method init( statement:Cmd )
      init
      if (statement) add( statement )

    method init( statement1:Cmd, statement2:Cmd )
      init
      if (statement1) add( statement1 )
      if (statement2) add( statement2 )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdStatementList
      local result = CmdStatementList( count )
      forEach (cmd in this)
        cmd = cmd.cloned( clone_args, new_t )
        if (cmd ) result.add( cmd )
      endForEach
      return result

    method evaled (scope:Scope, debug=false:Logical, ret=true:Logical)->Value[]
      local r : Value[]
      if (ret) r = Value[]
      forEach (cmd in this)
        local v = cmd.eval(scope)
        if (r) r.add(v)
        if (debug) println ">>> " + v
      endForEach
      return r

#{
    method resolve( scope:Scope, &use_separate_results_list )
      local result = CmdStatementList( count )

      local original_body = scope.this_body
      scope.this_body = result

      local original_statement = scope.this_statement

      forEach (cmd in this)
        scope.this_statement = cmd
        cmd = cmd.resolve( scope )
        cmd.add_to( result )
      endForEach

      clear.add( result )

      forEach (statement in this) statement.exit_scope( scope )

      scope.this_statement = original_statement
      scope.this_body = original_body
}#
endClass


#------------------------------------------------------------------------------
# Args
#------------------------------------------------------------------------------
class CmdArgs : Cmd[]
  METHODS
    method init
      prior.init

    method init( initial_capacity:Int32)
      prior.init( initial_capacity )

    method init( arg:Cmd )
      init
      add( arg )

    method init( arg1:Cmd, arg2:Cmd )
      init
      add( arg1 ).add( arg2 )

    method init( arg1:Cmd, arg2:Cmd, arg3:Cmd )
      init
      add( arg1 ).add( arg2 ).add( arg3 )

    method cloned->CmdArgs
      # Need two cloned() overloads here because this one overrides the base class
      # cloned().
      return cloned( null )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdArgs
      local result = CmdArgs( count )
      forEach (cmd in this) result.add( cmd.cloned( clone_args, new_t ) )
      return result

    method evaled (scope:Scope)->Value[]
      local r = Value[]
      forEach (arg in this)
        r.add(arg.eval(scope))
      endForEach
      return r


#{
    method resolve( scope:Scope )
      forEach (i of this)
        local arg = this[i].resolve( scope )
        this[i] = arg
        arg.require_type.organize(scope)
      endForEach
}#
endClass


#------------------------------------------------------------------------------
# Statements
#------------------------------------------------------------------------------
class CmdStatement : Cmd
  METHODS
endClass

class CmdLocalDeclaration : CmdStatement
  PROPERTIES
    local_info          : Local
    skip_initialization : Logical

  METHODS
    method init( t, local_info, skip_initialization=false )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      #local task_args = (clone_args as TaskArgs)
      #if (task_args)
      #  local new_value = local_info.initial_value
      #  if (new_value) new_value = new_value.cloned( clone_args, new_t )
      #  return task_args.replace_write_local( t, local_info, new_value )
      #else
        return CmdLocalDeclaration( t, local_info, skip_initialization )
      #endIf

    #method exit_scope( scope:Scope )
    #  scope.pop_local

    method eval( scope:Scope )->Value
      local rhs = UndefinedValue
      if (local_info.initial_value)
        rhs = local_info.initial_value.eval(scope)
      endIf
      scope.create(local_info.name, rhs, t)
      return rhs

#{
    method resolve( scope:Scope )->Cmd
      if (local_info.initial_value)
        local_info.initial_value = local_info.initial_value.resolve( scope )
        local initial_value_type = local_info.initial_value.require_type
        if (local_info.type is null) local_info.type = initial_value_type
      endIf

      if (local_info.type is null)
        throw t.error( "Cannot determine the type of the local variable - either assign an initial value (local $ = ...) or assign a type (local $ : Int32)." (local_info.name,local_info.name) )
      endIf

      if (local_info.initial_value)
        local_info.initial_value = local_info.initial_value.cast_to(local_info.type,scope).resolve( scope )
      endIf

      local_info.type.organize(scope)
      scope.push_local( local_info )

      return this

    method to->String
      if (local_info.type)
        return "CmdLocalDeclaration($:$)" (local_info.name,local_info.type.name)
      else
        return "CmdLocalDeclaration($)" (local_info.name)
      endIf
}#

endClass


class CmdReturn : CmdStatement
  PROPERTIES
    value : Cmd

  METHODS
    method init( t, value=null )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
#{
      local task_args = (clone_args as TaskArgs)
      if (task_args)
        return task_args.create_return( t, clone(value,clone_args,new_t) )
      else
}#
        return CmdReturn( t, clone(value,clone_args,new_t) )
#{
      endIf
}#
#{
    method resolve( scope:Scope )->Cmd
      if (value)
        if (not scope.this_method.return_type)
          throw t.error( "$ is not declared as returning a value." (scope.this_method.signature) )
        endIf
        value = value.resolve( scope ).cast_to(scope.this_method.return_type,scope).resolve( scope )

      elseIf (scope.this_method.is_initializer)
        # 'return' -> 'return this'
        value = CmdLiteralThis( t, scope.this_method.type_context ).resolve( scope )
      endIf
      return this
}#

    method eval (scope:Scope)->Value
      throw ReturnException(value.eval(scope))

    method to->String
      if (value) return "CmdReturn($)" (value)
      else       return "CmdReturn(nil)"

#    method type->Type
#      return value.type
endClass


#------------------------------------------------------------------------------
# Control Structures
#------------------------------------------------------------------------------
class CmdControlStructure : CmdStatement
  ENUMERATE
    type_block
    type_contingent
    type_if
    type_else_if  # A nested if/else that was originally an elseIf
    type_try
    type_which

    type_first_loop
    type_loop
    type_while
    type_forEach

    type_use

  PROPERTIES
    statements          : CmdStatementList
    control_type        : Int32
    contains_yield      : Logical
    escape_label        : String
    escape_label_used   : Logical
    upkeep_label        : String
#    task_escape_section : CmdTaskControlSection
#    task_upkeep_section : CmdTaskControlSection
    cloned_command      : CmdControlStructure
    # Allows escape and nextIteration commands to update their target

  METHODS
    method init( t )
      statements = CmdStatementList()

    method requires_semicolon->Logical
      return false

    method set_control_logic( control_structure:CmdControlStructure )->Cmd
      control_type   = control_structure.control_type
      contains_yield = control_structure.contains_yield
      escape_label   = control_structure.escape_label
      upkeep_label   = control_structure.upkeep_label
      return this

endClass


class CmdBlock : CmdControlStructure
  PROPERTIES
    statements : CmdStatementList

  METHODS
    method init( t, control_type=CmdControlStructure.type_block )
      statements = CmdStatementList()

    method init( t, statements, control_type=CmdControlStructure.type_block )

    method init( cmd:Cmd )
      t = cmd.t
      statements = CmdStatementList( cmd )
      control_type = CmdControlStructure.type_block

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      #{
      local task_args = (clone_args as TaskArgs)
      if (task_args and this.contains_yield)
        forEach (statement in statements)
          task_args.add( statement.cloned(task_args) )
        endForEach
        return null
      else
      }#
        local result = CmdBlock( t, null )
        result.set_control_logic( this )
        cloned_command = result
        result.statements = statements.cloned( clone_args, new_t )
        return result
      #endIf

    method requires_semicolon->Logical
      return false

    method eval( scope:Scope )->Value
      #scope.control_stack.add( this )

      #statements.resolve( scope )

      #scope.control_stack.remove_last
      #return this

      local new_scope = RoseObject()
      new_scope.next = scope
      try
        statements.evaled(new_scope,&!ret)
      catch (ex: EscapeBlockException)
        noAction
      endTry

      return UndefinedValue

endClass


class CmdIf : CmdControlStructure
  PROPERTIES
    condition           : Cmd
    else_statements     : CmdStatementList

  METHODS
    method init( t, condition=null, control_type=CmdControlStructure.type_if )
      statements = CmdStatementList()

    method init( t, condition, statements, control_type=CmdControlStructure.type_if )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      #{
      local task_args = (clone_args as TaskArgs)
      if (task_args and this.contains_yield)
        local next_section = task_args.create_section
        local end_section = task_args.create_section
        task_escape_section = end_section
        task_args.add_conditional_jump( CmdLogicalNot(t,condition.cloned( clone_args, new_t )), next_section )
        forEach (statement in statements)
          task_args.add( statement.cloned(task_args) )
        endForEach
        task_args.add_jump( t, end_section )
        task_args.begin_section( next_section )

        if (else_statements)
          forEach (statement in else_statements)
            task_args.add( statement.cloned(task_args) )
          endForEach
        endIf

        task_args.add_jump( t, end_section )
        task_args.begin_section( end_section )
        if (end_section.ip < task_args.cmd_task_control.sections.count)
          # We're somewhere in the middle; jump to the end
          task_args.jump_to_new_section( t )
        endIf
        return null

      else
      }#
        local result = CmdIf( t, condition.cloned( clone_args, new_t ), control_type )
        result.set_control_logic( this )
        cloned_command = result
        result.statements = statements.cloned( clone_args, new_t )

        result.else_statements = clone( else_statements, clone_args, new_t )

        return result

      #endIf

    method eval( scope:Scope )->Value
      if (condition.eval(scope)->Logical)
        if (statements)
          local new_scope = RoseObject()
          new_scope.next = scope
          try
            statements.evaled(new_scope,&!ret)
          catch (ex:EscapeIfException)
            noAction
          endTry
        endIf
      else
        if (else_statements)
          local new_scope = RoseObject()
          new_scope.next = scope
          try
            else_statements.evaled(new_scope,&!ret)
          catch (ex:EscapeIfException)
            noAction
          endTry
        endIf
      endIf
      return UndefinedValue

#{
    method resolve( scope:Scope )->Cmd
      condition = condition.resolve( scope )
      condition = condition.require_logical( scope )

      if (condition instanceOf CmdLiteral)
        # If the condition is a literal true or false, clear the statements
        # in the false or true section.  We can't get rid of the 'if' entirely
        # because there might be an escapeIf directive in the remaining code.
        if (condition->Logical) else_statements = null
        else                    statements.clear
      endIf

      scope.control_stack.add( this )
      statements.resolve( scope )
      if (else_statements) else_statements.resolve( scope )

      scope.control_stack.remove_last
      return this
}#
endClass

#{

class CmdWhich : CmdControlStructure
  PROPERTIES
    expression   : Cmd
    cases        : CmdWhichCase[]
    case_others  : CmdWhichCase

  METHODS
    method init( t, expression, cases=CmdWhichCase[], case_others=null, control_type=CmdControlStructure.type_which )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdWhich
      if (new_t) t = new_t
      local result = CmdWhich( t, expression.cloned( clone_args, new_t ), null )
      result.set_control_logic( this )
      cloned_command = result

      local cloned_cases = CmdWhichCase[]( cases.count )
      forEach (c in cases) cloned_cases.add( c.cloned( clone_args, new_t ) )
      result.cases = cloned_cases

      if (case_others) result.case_others = case_others.cloned( clone_args, new_t )
      return result

    method add_case( case_t:Token )->CmdWhichCase
      local result = CmdWhichCase( case_t )
      cases.add( result )
      return result

    method add_case_others( case_t:Token )->CmdWhichCase
      local result = CmdWhichCase( case_t )
      case_others = result
      return result

    method resolve( scope:Scope )->Cmd

      # Need to resolve all the cases and statements before deciding whether
      # to convert this to an if/elseIf block or a Switch.  We'll do Switch
      # if all the cases are literal values and if no case contains a 'yield'.
      scope.control_stack.add( this )

      expression = expression.resolve( scope )
      if (expression.require_type.is_enum)
        expression = CmdAccess( t, expression, "value" ).resolve( scope )
      endIf

      local all_literal_cases = true

      local expression_type = expression.require_type
      if (expression_type is not Program.type_Int32 and expression_type is not Program.type_Character)
        if (expression_type is Program.type_Byte)
          expression = expression.cast_to(Program.type_Int32,scope).resolve( scope )
        else
          all_literal_cases = false  # prevent conversion to C 'switch'
        endIf
      endIf

      forEach (c in cases)
        c.resolve_conditions( scope )
        if (all_literal_cases)
          forEach (condition in c.conditions)
            if (not condition.is_literal or condition instanceOf CmdLiteralString)
              all_literal_cases = false
              escapeForEach
            endIf
          endForEach
        endIf
        c.statements.resolve( scope )
      endForEach
      if (case_others)
        case_others.conditions.resolve( scope )
        case_others.statements.resolve( scope )
      endIf

      scope.control_stack.remove_last()

      # Convert to switch?
      if (all_literal_cases and not this.contains_yield)
        return CmdSwitch( t, expression, cases, case_others ).set_control_logic( this )
      endIf

      local result = CmdBlock( t, CmdControlStructure.type_which )
      result.set_control_logic( this )
      expression = expression.resolve( scope )

      local var_name       : String
      local expression_var : Local
      if (expression instanceOf CmdReadLocal)
        expression_var = (expression as CmdReadLocal).local_info
        var_name = expression_var.name
      else
        var_name = Program.create_unique_id
        expression_var = scope.this_method.add_local( t, var_name, expression.require_type, expression )
        result.statements.add( CmdLocalDeclaration(t,expression_var) )
      endIf

      if (cases.count)
        local cmd_if = CmdIf( expression.t, cases.first.as_conditional(var_name), cases.first.statements )
        local cur_if = cmd_if
        forEach (i of cases)
          if (i > 0)
            local c = cases[i]
            local cmd_else_if = CmdIf( c.t, c.as_conditional(var_name), CmdControlStructure.type_else_if )
            cmd_else_if.statements = c.statements

            cur_if.else_statements = CmdStatementList( cmd_else_if )
            cur_if = cmd_else_if
          endIf
        endForEach
        if (case_others)
          cur_if.else_statements = case_others.statements
        endIf
        result.statements.add( cmd_if )

      elseIf (case_others)
        # 'others' statements always happen
        forEach (cmd in case_others.statements) result.statements.add(cmd)
      endIf

      return result.resolve( scope )
endClass


class CmdSwitch : CmdControlStructure
  PROPERTIES
    expression   : Cmd
    cases        : CmdWhichCase[]
    case_others  : CmdWhichCase

  METHODS
    method init( t, expression, cases=CmdWhichCase[], case_others=null, control_type=CmdControlStructure.type_which )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdSwitch
      if (new_t) t = new_t
      local result = CmdSwitch( t, expression.cloned( clone_args, new_t ), null )
      result.set_control_logic( this )
      cloned_command = result

      local cloned_cases = CmdWhichCase[]( cases.count )
      forEach (c in cases) cloned_cases.add( c.cloned( clone_args, new_t ) )
      result.cases = cloned_cases

      if (case_others) result.case_others = case_others.cloned( clone_args, new_t )
      return result

    method resolve( scope:Scope )->Cmd
      scope.control_stack.add( this )

      expression = expression.resolve( scope )
      forEach (c in cases)
        c.conditions.resolve( scope )
        c.statements.resolve( scope )
      endForEach
      if (case_others)
        case_others.conditions.resolve( scope )
        case_others.statements.resolve( scope )
      endIf

      scope.control_stack.remove_last()
      return this

endClass

class CmdWhichCase : Cmd
  PROPERTIES
    conditions : CmdArgs
    statements : CmdStatementList

  METHODS
    method init( t, conditions=CmdArgs(), statements=CmdStatementList() )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdWhichCase
      if (new_t) t = new_t
      return CmdWhichCase( t, conditions.cloned( clone_args, new_t ), statements.cloned( clone_args, new_t ) )

    method as_conditional( expression_var_name:String )->Cmd
      local cmd : Cmd
      forEach (condition in conditions)
        if (cmd)
          cmd = CmdLogicalOr( t, cmd, CmdCompareEQ(t,CmdAccess(t,expression_var_name),condition) )
        else
          cmd = CmdCompareEQ( t, CmdAccess(t,expression_var_name), condition )
        endIf
      endForEach
      return cmd

    method resolve_conditions( scope:Scope )->CmdWhichCase
      conditions.resolve( scope )
      forEach (condition at index in conditions)
        if (condition.require_type.is_enum)
          local cmd_create_compound = condition as CmdCreateCompound
          if (cmd_create_compound)
            conditions[ index ] = cmd_create_compound.args.first
          else
            conditions[ index ] = CmdAccess( t, condition,"value" )
          endIf
        endIf
      endForEach
      return this


endClass


class CmdContingent : CmdControlStructure
  PROPERTIES
    satisfied_statements   : CmdStatementList
    unsatisfied_statements : CmdStatementList

    satisfied_label        : String
    unsatisfied_label      : String

    satisfied_section   : CmdTaskControlSection
    unsatisfied_section : CmdTaskControlSection

  METHODS
    method init( t, statements=CmdStatementList() )
      control_type = CmdControlStructure.type_contingent

    method cloned( clone_args:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      local task_args = (clone_args as TaskArgs)
      if (task_args and this.contains_yield)
        satisfied_section = task_args.create_section
        unsatisfied_section = task_args.create_section
        local end_section = task_args.create_section
        task_escape_section = end_section

        forEach (statement in statements)
          task_args.add( statement.cloned(task_args) )
        endForEach
        task_args.add_jump( t, satisfied_section )

        task_args.begin_section( satisfied_section )
        if (satisfied_statements)
          forEach (statement in satisfied_statements)
            task_args.add( statement.cloned(task_args) )
          endForEach
        endIf
        task_args.add_jump( t, end_section )

        task_args.begin_section( unsatisfied_section )
        if (unsatisfied_statements)
          forEach (statement in unsatisfied_statements)
            task_args.add( statement.cloned(task_args) )
          endForEach
        endIf
        task_args.add_jump( t, end_section )

        task_args.begin_section( end_section )
        if (end_section.ip < task_args.cmd_task_control.sections.count)
          # We're somewhere in the middle; jump to the end
          task_args.jump_to_new_section( t )
        endIf
        return null

      else
        local result = CmdContingent( t, null )
        result.set_control_logic( this )
        cloned_command = result

        result.statements = statements.cloned( clone_args, new_t )
        result.satisfied_statements = clone( satisfied_statements, clone_args, new_t )
        result.unsatisfied_statements = clone( unsatisfied_statements, clone_args, new_t )

        return result
      endIf

    method resolve( scope:Scope )->CmdContingent
      scope.control_stack.add( this )

      if (not escape_label) escape_label = Program.create_unique_id

      statements.resolve( scope )
      if (satisfied_statements)   satisfied_statements.resolve( scope )
      if (unsatisfied_statements) unsatisfied_statements.resolve( scope )

      scope.control_stack.remove_last
      return this

    method set_control_logic( original:CmdControlStructure )->Cmd
      prior.set_control_logic( original )
      satisfied_label   = (original as CmdContingent).satisfied_label
      unsatisfied_label = (original as CmdContingent).unsatisfied_label
      return this

endClass
}#


#------------------------------------------------------------------------------
# Loops
#------------------------------------------------------------------------------
class CmdGenericLoop : CmdControlStructure
  PROPERTIES
    control_statements : CmdStatementList
    condition          : Cmd
    upkeep             : CmdStatementList

  METHODS
    method init( t, control_type, condition, statements=CmdStatementList(), upkeep=null, control_statements=null )

    method init( t, control_type, condition, statements=CmdStatementList(), upkeep_cmd:Cmd, control_statements=null )
      if (upkeep_cmd)
        upkeep = CmdStatementList(1)
        upkeep.add( upkeep_cmd )
      endIf

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
#{
      local task_args = (clone_args as TaskArgs)
      if (task_args and this.contains_yield)
        # Control variable initialization
        if (control_statements)
          forEach (statement in control_statements)
            task_args.add( statement.cloned(task_args) )
          endForEach
        endIf

        # Termination Test
        local condition_section = task_args.jump_to_new_section(t)
        local after_section = task_args.create_section
        task_escape_section = after_section
        task_upkeep_section = task_args.create_section
        if (condition)
          task_args.add_conditional_jump( CmdLogicalNot(t,clone(condition,clone_args,new_t)), after_section )
        endIf

        # Main Body
        forEach (statement in statements)
          task_args.add( statement.cloned(task_args) )
        endForEach

        task_args.add_jump( t, task_upkeep_section )
        task_args.begin_section( task_upkeep_section )

        # Upkeep
        if (upkeep)
          forEach (statement in upkeep)
            task_args.add( statement.cloned(task_args) )
          endForEach
        endIf

        # Jump back to Termination Test
        task_args.add_jump( t, condition_section )

        task_args.begin_section( after_section )
        if (after_section.ip < task_args.cmd_task_control.sections.count)
          # We're somewhere in the middle; jump to the end
          task_args.jump_to_new_section( t )
        endIf

        return null

      else
}#
        local result = CmdGenericLoop( t, control_type, clone(condition,clone_args,new_t), null )
        result.set_control_logic( this )
        cloned_command = result

        result.statements = statements.cloned( clone_args, new_t )
        result.upkeep = clone( upkeep, clone_args, new_t )

        result.control_statements = clone( control_statements, clone_args, new_t )
        return result
#      endIf

    method add_control_var( v:Local )
      if (not control_statements) control_statements = CmdStatementList()
      control_statements.add( CmdLocalDeclaration(v.t,v) )

    method add_upkeep( cmd:Cmd )
      if (not upkeep) upkeep = CmdStatementList()
      upkeep.add( cmd )

    method eval(scope:Scope)->Value

      local new_scope = RoseObject()
      new_scope.next = scope

      if (control_statements) control_statements.evaled(new_scope,&!ret)

      loop
        if (condition and (condition.eval(new_scope)->Logical == false)) escapeLoop

        try
          statements.evaled(new_scope,&!ret)
        catch(ex:EscapeException)
          if (ex.control_type != control_type)
            throw ex
          endIf
        endTry

        upkeep.evaled(new_scope,&!ret)
      endLoop

      return UndefinedValue


#{
    method resolve( scope:Scope )->Cmd
      scope.control_stack.add( this )
      if (control_statements)
        forEach (i of control_statements)
          control_statements[i] = control_statements[i].resolve( scope )
        endForEach
      endIf

      if (condition) condition = condition.resolve( scope ).require_logical( scope )
      statements.resolve( scope )

      if (upkeep) upkeep.resolve( scope )

      if (control_statements)
        forEach (statement in control_statements) statement.exit_scope( scope )
      endIf

      scope.control_stack.remove_last
      return this
}#

    method to->String
      return "CmdGenericLoop(statements:$ control_statements:$ condition:$ upkeep:$)" (statements,control_statements,condition,upkeep)

endClass

class CmdForEach : CmdControlStructure
  PROPERTIES
    # At most one of control_var_name and control_var_tuple will be set.
    # In the latter case, it's because you're doing a destructuring assignment of the control variable.
    control_var_name    : String
    control_var_tuple   : CmdTuple
    index_var_name      : String
    collection_var_name : String
    collection          : Cmd
    first_cmd           : Cmd
    last_cmd            : Cmd
    step_cmd            : Cmd

  METHODS
    method init( t, control_var_name, index_var_name, collection, step_cmd, statements=CmdStatementList() )
      control_type = CmdControlStructure.type_forEach

    method init( t, control_var_tuple, index_var_name, collection, step_cmd, statements=CmdStatementList() )
      control_type = CmdControlStructure.type_forEach
      control_var_tuple.synthesize_variables = true

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      local result = CmdForEach( t, control_var_name, index_var_name, collection.cloned( clone_args, new_t ), clone(step_cmd,clone_args,new_t), null )
      result.control_var_tuple = clone( control_var_tuple, clone_args, new_t ) as CmdTuple
      result.first_cmd = clone( first_cmd, clone_args, new_t )
      result.last_cmd = clone( last_cmd, clone_args, new_t )
      result.set_control_logic( this )
      cloned_command = result

      result.statements = statements.cloned( clone_args, new_t )
      result.collection_var_name = collection_var_name

      return result

#{
    method resolve( scope:Scope )->Cmd
      scope.control_stack.add( this )

      collection = collection.resolve( scope )
      local collection_type = collection.require_type.organize(scope)

      local has_count = (collection_type.find_property("count") or collection_type.find_method("count()"))
      local m_at  = collection_type.find_method("at(Int32)")
      local m_get = collection_type.find_method("get(Int32)")
      local has_get = m_get or m_at

      local step_size = 1
      if (step_cmd)
        step_cmd = step_cmd.resolve( scope )
        local literal_integer_cmd = step_cmd as CmdLiteralInt32
        if (literal_integer_cmd)
          step_size = literal_integer_cmd.value
        else
          throw step_cmd.t.error( "Literal integer value expected." )
        endIf
      endIf

      if (not collection_var_name) collection_var_name = Program.create_unique_id

      if (has_count and has_get)
        if (m_at) m_get = m_at  # prefer at(Int32) over get(Int32)

        collection = collection.resolve( scope )
        local collection_var = scope.this_method.add_local( t, collection_var_name, collection.require_type, collection )

        if (not index_var_name) index_var_name = Program.create_unique_id
        local index_var = scope.this_method.add_local( t, index_var_name, Program.type_Int32 )
        local last_var : Local
        if (step_size >= 0)
          if (first_cmd) index_var.initial_value = first_cmd
          else           index_var.initial_value = CmdLiteralInt32( t, 0 )
          last_var = scope.this_method.add_local( t, Program.create_unique_id, Program.type_Int32 )
          if (last_cmd)
            last_var.initial_value = last_cmd
            last_cmd = CmdReadLocal( t, last_var )
          else
            last_var.initial_value = CmdAccess( t, CmdReadLocal(t,collection_var), "count" )
            last_var.initial_value = CmdSubtract( t, last_var.initial_value, CmdLiteralInt32(t,1) )
            last_cmd = CmdReadLocal( t, last_var )
          endIf
        else
          if (first_cmd)
            index_var.initial_value = first_cmd
          else
            index_var.initial_value = CmdSubtract( t, CmdAccess(t,CmdReadLocal(t,collection_var), "count"), CmdLiteralInt32(t,1) )
          endIf
          if (not last_cmd) last_cmd = CmdLiteralInt32( t, 0 )
        endIf

        local control_var : Local
        if (control_var_name)
          control_var = scope.this_method.add_local( t, control_var_name )
          control_var.initial_value = CmdAccess( t, CmdReadLocal(t,collection_var), m_get.name, CmdArgs(CmdReadLocal(t,index_var)) )
          statements.insert( CmdLocalDeclaration(control_var.t,control_var) )
        elseIf (control_var_tuple)
          local control_tuple = CmdAssign(control_var_tuple.t, control_var_tuple, ...
            CmdAccess( t, CmdReadLocal(t,collection_var), m_get.name, CmdArgs(CmdReadLocal(t,index_var)) ))
          statements.insert(control_tuple)
        endIf

        local modifier : Cmd
        if (step_size >= -1 and step_size <= 1)
          modifier = CmdAdjustLocal(t,index_var,step_size)
        elseIf (step_size >= 0)
          modifier = CmdModifyAndAssign(t,CmdAccess(t,index_var.name),TokenType.symbol_plus_equals,CmdLiteralInt32(t,step_size))
        else
          modifier = CmdModifyAndAssign(t,CmdAccess(t,index_var.name),TokenType.symbol_minus_equals,CmdLiteralInt32(t,-step_size))
        endIf

        local condition : Cmd
        if (step_size >= 0) condition = CmdCompareLE( t, CmdReadLocal(t,index_var), last_cmd )
        else                condition = CmdCompareGE( t, CmdReadLocal(t,index_var), last_cmd )

        local result = CmdGenericLoop( t, CmdControlStructure.type_forEach, condition, statements )
        result.set_control_logic( this )
        result.add_control_var( collection_var )
        result.add_control_var( index_var )
        if (last_var) result.add_control_var( last_var )
        result.add_upkeep( modifier )

        scope.control_stack.remove_last
        return result.resolve( scope )

      else
        # commandBlock
        #   local reader = expression
        #   local index  = 0
        #   while (reader.has_another)
        #     local control_var = reader.read
        #     statements
        #     ++index
        #   endWhile
        if (first_cmd)
          throw first_cmd.t.error( "'forEach' cannot specify a 'from' when iterating over a reader-type collection." )
        endIf

        local has_another = (collection_type.find_property("has_another") or collection_type.find_method("has_another()"))
        local m_read  = collection_type.find_method("read()")
        if (not has_another or not m_read)
          throw collection.t.error( "Illegal iteration target - forEach requires either an indexed collection (.count, .get/.at) or a reader (.has_another, .read)." )
        endIf
        if (not m_read.return_type) throw collection.t.error( "Object's read() method does not return a value." )
        if (step_cmd)
          throw step_cmd.t.error( "Cannot specify a step size for a reader - only for an indexed collection." )
        endIf

        local reader_var = scope.this_method.add_local( t, collection_var_name, collection_type, collection  )
        local index_var : Local
        if (index_var_name)
          index_var = scope.this_method.add_local( t, index_var_name, Program.type_Int32, CmdLiteralInt32(t,0) )
        endIf

        if (control_var_name)
          local control_var = scope.this_method.add_local( t, control_var_name, m_read.return_type,
            CmdAccess(collection.t,CmdAccess(collection.t,reader_var.name),"read")  )
          statements.insert( CmdLocalDeclaration(collection.t,control_var) )
        elseIf (control_var_tuple)
          local control_tuple = CmdAssign(control_var_tuple.t, control_var_tuple, ...
            CmdAccess(collection.t,CmdAccess(collection.t,reader_var.name),"read")  )
          statements.insert(control_tuple)
        else
          statements.insert( CmdAccess(collection.t,CmdAccess(collection.t,reader_var.name),"read")  )
        endIf

        local rt = reader_var.t
        local cmd_loop = CmdGenericLoop( t, CmdControlStructure.type_forEach, CmdAccess(rt,CmdReadLocal(rt,reader_var),"has_another"), statements )
        cmd_loop.set_control_logic( this )
        cmd_loop.add_control_var( reader_var )
        if (index_var)
          cmd_loop.add_control_var( index_var )
          cmd_loop.add_upkeep( CmdAdjustLocal(t,index_var,1) )
        endIf

        scope.control_stack.remove_last
        return cmd_loop.resolve( scope )

      endIf
      return this
}#

endClass


class CmdTry : CmdControlStructure
  PROPERTIES
    catches : CmdCatch[]

  METHODS
    method init( t, statements=CmdStatementList(), catches=CmdCatch[] )
      control_type = type_try

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdTry
      if (new_t) t = new_t
      local result = CmdTry( t, null, null )
      result.set_control_logic( this )
      cloned_command = result

      result.statements = statements.cloned( clone_args, new_t )

      local new_catches = CmdCatch[]
      forEach (c in catches) new_catches.add( c.cloned( clone_args, new_t ) )
      result.catches = new_catches

      return result

    method add_catch( catch_t:Token )->CmdCatch
      local c = CmdCatch( catch_t )
      catches.add( c )
      return c

    method eval( scope:Scope )->Value
      local try_scope = RoseObject()
      try_scope.next = scope
      try
        statements.evaled(try_scope, &!ret)
      catch(EscapeTryException)
        noAction
      catch(ex:RoseException)
        require(false || "TODO")
        #{
        require(ex.value.is_object)
        local real_ex = ex.value->Object as RoseObject
        require(real_ex)
        local rose_ex_type = real_ex.geto("__type__")
        local handled = false
        forEach (c in catches)
          if (not ex.type_info.is_subclass(t)) nextIteration
          local catch_type = scope.geto(c.error_type)
          if (not real_ex_type.is_subclass(catch_type)) nextIteration

          local catch_scope = RoseObject()
          catch_scope.next = scope
          if (c.error_var) catch_scope.set(c.error_var.name, real_ex, &force)
          c.statements.evaled(catch_scope, &!ret)
          handled = true
          escapeForEach
        endForEach
        if (not handled) throw ex
        }#

      catch(ex:Exception)
        local handled = false
        forEach (c in catches)
          local t = TypeInfo.get(c.error_type)
          if (not t) nextIteration
          if (not ex.type_info.is_subclass(t)) nextIteration

          local catch_scope = RoseObject()
          catch_scope.next = scope
          if (c.error_var) catch_scope.set(c.error_var.name, ex, &force)
          c.statements.evaled(catch_scope, &!ret)
          handled = true
          escapeForEach
        endForEach
        if (not handled) throw ex
      endTry
      return UndefinedValue
#{
    method resolve( scope:Scope )->Cmd
      scope.control_stack.add( this )

      statements.resolve( scope )
      forEach (c in catches) c.resolve( scope )

      if (contains_yield)
        throw t.error( "try/catch blocks cannot contain 'yield' statements." )
      endIf

      scope.control_stack.remove_last

      return this
}#
endClass

class CmdCatch : Cmd
  PROPERTIES
    # error_type should definitely be set.  error_var may also be.
    error_var  : Local  # catch(err:Error)
    error_type : String # catch(Error)

    statements : CmdStatementList

  METHODS
    method init( t, error_var=null, error_type=null, statements=CmdStatementList() )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdCatch
      if (new_t) t = new_t
      return CmdCatch( t, error_var, error_type, statements.cloned( clone_args, new_t ) )
endClass

class CmdThrow : Cmd
  PROPERTIES
    expression : Cmd

  METHODS
    method init( t, expression )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdThrow
      if (new_t) t = new_t
      return CmdThrow( t, expression.cloned( clone_args, new_t ) )

    method eval( scope:Scope )->Value
      local e = expression.eval(scope)
      if (e.is_object and (e->Object instanceOf Exception))
        throw e->Object
      endIf

      throw RoseException(e, t)

      return UndefinedException

endClass

#{

class CmdTryExpression : Cmd
  PROPERTIES
    try_expression  : Cmd
    else_expression : Cmd
    result_var      : Local

  METHODS
    method init( t, try_expression, else_expression, result_var )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdTryExpression( t, try_expression.cloned( clone_args, new_t ), else_expression.cloned( clone_args, new_t ), result_var )

    method implicit_type( scope:Scope )->Type
      return try_expression.implicit_type( scope )

    method resolve( scope:Scope )->Cmd
      try_expression = try_expression.resolve( scope ).require_value
      else_expression = else_expression.resolve( scope ).require_value

      local try_type = try_expression.type

      if (else_expression.type is not try_type)
        else_expression = else_expression.cast_to( try_type, scope ).resolve( scope )
      endIf

      result_var.type = try_type

      local cmd_try = CmdTry( t )
      cmd_try.statements.add( CmdWriteLocal(t, result_var, try_expression) )

      local cmd_catch = cmd_try.add_catch( t )
      cmd_catch.error_type = Program.type_Exception
      cmd_catch.statements.add( CmdWriteLocal(t, result_var, else_expression) )

      return cmd_try.resolve( scope )
endClass

#------------------------------------------------------------------------------
# escape and nextIteration
#------------------------------------------------------------------------------
}#
class CmdEscape : Cmd
  PROPERTIES
    control_type : Int32
    target_cmd   : CmdControlStructure

  METHODS
    method init( t, control_type, target_cmd=null )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      #{
      if (target_cmd.task_escape_section)
        local task_args = (clone_args as TaskArgs)
        return task_args.create_escape( t, target_cmd.task_escape_section )
      else
      }#
        local new_target = target_cmd
        while (new_target.cloned_command) new_target = new_target.cloned_command
        return CmdEscape( t, control_type, new_target )
      #endIf

    method eval( scope:Scope )->Value
      which (control_type)
        case CmdControlStructure.type_if
          throw EscapeIfException(t)
        case CmdControlStructure.type_contingent
          throw EscapeContingentException(t)
        case CmdControlStructure.type_loop
          throw EscapeLoopException(t)
        case CmdControlStructure.type_try
          throw EscapeTryException(t)
        case CmdControlStructure.type_forEach
          throw EscapeForEachException(t)
        case CmdControlStructure.type_block
          throw EscapeBlockException(t)
        case CmdControlStructure.type_while
          throw EscapeWhileException(t)
      endWhich
      throw t.error("Unknown block escape type")
endClass

class EscapeException : RoseError
  PROPERTIES
    control_type = -1 : Int32

  METHODS
    method init (t:Token)
      message = "Nothing to escape"
      filepath = t.filepath
      line = t.line
      column = t.column
endClass

class EscapeBlockException : EscapeException;
class EscapeContingentException : EscapeException;
class EscapeIfException : EscapeException;
class EscapeWhileException : EscapeException
  PROPERTIES
    control_type = CmdControlStructure.type_while : Int32
endClass
class EscapeLoopException : EscapeException
  PROPERTIES
    control_type = CmdControlStructure.type_loop : Int32
endClass
class EscapeForEachException : EscapeException
  PROPERTIES
    control_type = CmdControlStructure.type_forEach : Int32
endClass
class EscapeTryException : EscapeException;


class CmdNextIteration : Cmd
  PROPERTIES
    target_cmd   : CmdControlStructure

  METHODS
    method init( t, target_cmd=null )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      #{
      if (target_cmd.task_upkeep_section)
        local task_args = (clone_args as TaskArgs)
        return task_args.create_escape( t, target_cmd.task_upkeep_section )
      else
      }#
        local new_target = target_cmd
        while (new_target.cloned_command) new_target = new_target.cloned_command
        return CmdNextIteration( t, new_target )
      #endIf

    method eval( scope:Scope )->Value
      throw NextIterationException(t)

endClass

class NextIterationException : RoseError
  METHODS
    method init (t:Token)
      message = "No loop to iterate"
      filepath = t.filepath
      line = t.line
      column = t.column
endClass

#{
class CmdNecessary : Cmd
  PROPERTIES
    target_cmd   : CmdContingent
    condition    : Cmd

  METHODS
    method init( t, condition, target_cmd=null )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      if (target_cmd.unsatisfied_section)
        local task_args = (clone_args as TaskArgs)
        local cmd_jump = task_args.create_escape( t, target_cmd.unsatisfied_section )
        if (condition)
          return CmdIf( t, CmdLogicalNot(t,condition.cloned(task_args)), CmdStatementList(cmd_jump) )
        else
          return cmd_jump
        endIf
      else
        local new_target = target_cmd : CmdControlStructure
        while (new_target.cloned_command) new_target = new_target.cloned_command
        return CmdNecessary( t, clone(condition,clone_args,new_t), new_target as CmdContingent )
      endIf


    method resolve( scope:Scope )->Cmd
      if (condition) condition = condition.resolve( scope )

      local i = scope.control_stack.count
      while (i > 0)
        --i
        local cmd = scope.control_stack[i]
        if (cmd.control_type == CmdControlStructure.type_contingent)
          while (cmd.cloned_command) cmd = cmd.cloned_command
          local cmd_contingent = cmd as CmdContingent
          if (not cmd_contingent.unsatisfied_label) cmd_contingent.unsatisfied_label = Program.create_unique_id
          target_cmd = cmd_contingent
          return this
        endIf
      endWhile

      throw t.error( "No enclosing contingent." )

endClass


class CmdSufficient : Cmd
  PROPERTIES
    target_cmd   : CmdContingent
    condition    : Cmd

  METHODS
    method init( t, condition, target_cmd=null )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      if (target_cmd.satisfied_section)
        local task_args = (clone_args as TaskArgs)
        local cmd_jump = task_args.create_escape( t, target_cmd.satisfied_section )
        if (condition)
          return CmdIf( t, condition.cloned(task_args), CmdStatementList(cmd_jump) )
        else
          return cmd_jump
        endIf
      else
        local new_target = target_cmd : CmdControlStructure
        while (new_target.cloned_command) new_target = new_target.cloned_command
        return CmdSufficient( t, clone(condition,clone_args,new_t), new_target as CmdContingent )
      endIf


    method resolve( scope:Scope )->Cmd
      if (condition) condition = condition.resolve( scope )

      local i = scope.control_stack.count
      while (i > 0)
        --i
        local cmd = scope.control_stack[i]
        if (cmd.control_type == CmdControlStructure.type_contingent)
          while (cmd.cloned_command) cmd = cmd.cloned_command
          local cmd_contingent = cmd as CmdContingent
          if (not cmd_contingent.satisfied_label) cmd_contingent.satisfied_label = Program.create_unique_id
          target_cmd = cmd_contingent
          return this
        endIf
      endWhile

      throw t.error( "No enclosing contingent." )

endClass
}#

#------------------------------------------------------------------------------
# Literals
#------------------------------------------------------------------------------
class CmdLiteral : Cmd
  PROPERTIES
    value : Value

  METHODS
    method is_literal->Logical
      return true

    method init ( t, value )
      noAction

    method eval ( scope:Scope )->Value
      return value

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdLiteral( t, value )

    method to->String
      return "($ $)" (type_name, value)
endClass

class CmdLiteralInt32 : CmdLiteral
endClass

class CmdLiteralString : CmdLiteral
endClass

class CmdLiteralLogical : CmdLiteral
endClass

#{
class CmdLiteralNull : CmdLiteral
  METHODS
    method init( t )
}#
#{
    method cast_to( target_type:Type, scope:Scope, &allow_implicit_narrowing, &is_conversion )->Cmd
      if (target_type.is_optional)
        return CmdAccess( t, "$?"(target_type.element_type.name), CmdArgs() )
      else
        return prior.cast_to( target_type, scope )
      endIf
}#
#{
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdLiteralNull( t )

    method resolve( scope:Scope )->this
      return this

    method to->String
      return "null"
endClass
}#
#{
class CmdDefaultValue : CmdLiteral
  METHODS
    method init( t, of_type )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdDefaultValue( t, of_type )

    method is_literal_number->Logical
      if (not of_type.is_primitive) return false
      if (of_type is Program.type_Logical) return false
      return true

    method resolve( scope:Scope )->Cmd
      of_type.organize(scope)
      local default_value = of_type.create_default_value( t )
      if (of_type.is_reference)
        return CmdCastToType( t, default_value, of_type )
      else
        return default_value
      endIf

    method type->Type
      return of_type
endClass
}#

#{
class CmdLiteralNumber : CmdLiteral
  METHODS
    method is_literal_number->Logical
      return true
endClass

class CmdLiteralReal64 : CmdLiteralNumber
  PROPERTIES
    value : Real64

  METHODS
    method init( t, value )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdLiteralReal64( t, value )

    method cast_to( target_type:Type, scope:Scope, &allow_implicit_narrowing, &is_conversion )->Cmd
      if (target_type is Program.type_Real32)
        return CmdLiteralReal32( t, value )
      elseIf (target_type is Program.type_Int64)
        return CmdLiteralInt64( t, value )
      elseIf (target_type is Program.type_Int32)
        return CmdLiteralInt32( t, value )
      elseIf (target_type is Program.type_Character)
        return CmdLiteralCharacter( t, value )
      elseIf (target_type is Program.type_Byte)
        return CmdLiteralByte( t, value )
      else
        return prior.cast_to( target_type, scope )
      endIf

    method resolve( scope:Scope )->Cmd
      return this

    method to->Int32
      return value->Int32

    method to->Logical
      return value?

    method to->String
      return value

    method type->Type
      return Program.type_Real64
endClass


class CmdLiteralReal32 : CmdLiteralNumber
  PROPERTIES
    value : Real32

  METHODS
    method init( t, value )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdLiteralReal32( t, value )

    method cast_to( target_type:Type, scope:Scope, &allow_implicit_narrowing, &is_conversion )->Cmd
      if (target_type is Program.type_Real64)
        return CmdLiteralReal64( t, value )
      elseIf (target_type is Program.type_Int64)
        return CmdLiteralInt64( t, value )
      elseIf (target_type is Program.type_Int32)
        return CmdLiteralInt32( t, value )
      elseIf (target_type is Program.type_Character)
        return CmdLiteralCharacter( t, value )
      elseIf (target_type is Program.type_Byte)
        return CmdLiteralByte( t, value )
      else
        return prior.cast_to( target_type, scope )
      endIf

    method resolve( scope:Scope )->Cmd
      return this

    method to->Int32
      return value->Int32

    method to->Logical
      return value?

    method to->String
      return value

    method type->Type
      return Program.type_Real32
endClass


class CmdLiteralInt64 : CmdLiteralNumber
  PROPERTIES
    value : Int64

  METHODS
    method init( t, value )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdLiteralInt64( t, value )

    method cast_to( target_type:Type, scope:Scope, &allow_implicit_narrowing, &is_conversion )->Cmd
      if (target_type is Program.type_Real64)
        return CmdLiteralReal64( t, value )
      elseIf (target_type is Program.type_Real32)
        return CmdLiteralReal32( t, value )
      elseIf (target_type is Program.type_Int32)
        return CmdLiteralInt32( t, value )
      elseIf (target_type is Program.type_Character)
        return CmdLiteralCharacter( t, value )
      elseIf (target_type is Program.type_Byte)
        return CmdLiteralByte( t, value )
      else
        return prior.cast_to( target_type, scope )
      endIf

    method resolve( scope:Scope )->Cmd
      return this

    method to->Int32
      return value->Int32

    method to->Logical
      return value?

    method to->String
      return value

    method type->Type
      return Program.type_Int64
endClass


class CmdLiteralInt32 : CmdLiteralNumber
  PROPERTIES
    value : Int32

  METHODS
    method init( t, value )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdLiteralInt32( t, value )

    method cast_to( target_type:Type, scope:Scope, &allow_implicit_narrowing, &is_conversion )->Cmd
      if (target_type is Program.type_Real64)
        return CmdLiteralReal64( t, value )
      elseIf (target_type is Program.type_Real32)
        return CmdLiteralReal32( t, value )
      elseIf (target_type is Program.type_Int64)
        return CmdLiteralInt64( t, value )
      elseIf (target_type is Program.type_Character)
        return CmdLiteralCharacter( t, value )
      elseIf (target_type is Program.type_Byte)
        return CmdLiteralByte( t, value )
      else
        return prior.cast_to( target_type, scope )
      endIf

    method resolve( scope:Scope )->Cmd
      return this

    method to->Int32
      return value

    method to->Logical
      return value?

    method to->String
      return value

    method type->Type
      return Program.type_Int32
endClass


class CmdLiteralCharacter : CmdLiteralNumber
  PROPERTIES
    value : Character

  METHODS
    method init( t, value )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdLiteralCharacter( t, value )

    method cast_to( target_type:Type, scope:Scope, &allow_implicit_narrowing, &is_conversion )->Cmd
      if (target_type is Program.type_Real64)
        return CmdLiteralReal64( t, value )
      elseIf (target_type is Program.type_Real32)
        return CmdLiteralReal32( t, value )
      elseIf (target_type is Program.type_Int64)
        return CmdLiteralInt64( t, value )
      elseIf (target_type is Program.type_Int32)
        return CmdLiteralInt32( t, value )
      elseIf (target_type is Program.type_Byte)
        return CmdLiteralByte( t, value )
      else
        return prior.cast_to( target_type, scope )
      endIf

    method resolve( scope:Scope )->Cmd
      return this

    method to->Int32
      return value->Int32

    method to->Logical
      return value?

    method to->String
      return value

    method type->Type
      return Program.type_Character
endClass

class CmdLiteralByte : CmdLiteralNumber
  PROPERTIES
    value : Byte

  METHODS
    method init( t, value )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdLiteralByte( t, value )

    method cast_to( target_type:Type, scope:Scope, &allow_implicit_narrowing, &is_conversion )->Cmd
      if (target_type is Program.type_Real64)
        return CmdLiteralReal64( t, value )
      elseIf (target_type is Program.type_Real32)
        return CmdLiteralReal32( t, value )
      elseIf (target_type is Program.type_Int64)
        return CmdLiteralInt64( t, value )
      elseIf (target_type is Program.type_Int32)
        return CmdLiteralInt32( t, value )
      elseIf (target_type is Program.type_Character)
        return CmdLiteralCharacter( t, value )
      else
        return prior.cast_to( target_type, scope )
      endIf

    method resolve( scope:Scope )->Cmd
      return this

    method to->Int32
      return value->Int32

    method to->Logical
      return value?

    method to->String
      return value

    method type->Type
      return Program.type_Byte
endClass



class CmdLiteralLogical : CmdLiteral
  PROPERTIES
    value : Logical

  METHODS
    method init( t, value )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdLiteralLogical( t, value )

    method resolve( scope:Scope )->Cmd
      return this

    method to->Int32
      return select{ value:1 || 0 }

    method to->Logical
      return value?

    method to->String
      return value

    method type->Type
      return Program.type_Logical
endClass


class CmdLiteralString : CmdLiteral
  PROPERTIES
    value : String
    index : Int32

  METHODS
    method init( t, value, index=0 )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdLiteralString( t, value, index )

    method resolve( scope:Scope )->Cmd
      Program.type_String.resolve
      return this

    method to->Logical
      return value?

    method to->String
      return value

    method type->Type
      return Program.type_String
endClass
}#

class CmdFormattedString : Cmd
  PROPERTIES
    format : String
    args   : CmdArgs

  METHODS
    method init( t, format, args )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdFormattedString( t, format, args.cloned( clone_args, new_t ) )

    method eval( scope:Scope )->Value
      local cmd = StringBuilder()
      local fmt = format
      forEach (arg in args)
        local i = locate_marker( fmt )
        if (not i) throw t.error( "More arguments than format markers ('$') in formatted string." )
        if (i.value > 0)
          cmd.print(fmt.leftmost(i.value))
          fmt = fmt.from(i.value+1)
        else
          fmt = fmt.from(1)
        endIf
        cmd.print(arg.eval(scope))
      endForEach
      if (fmt.count)
        if (locate_marker(fmt))
          throw t.error( "More format markers ('$') than arguments in formatted string." )
        endIf
        cmd.print(fmt)
      endIf

      return cmd->String

    method locate_marker( fmt:String )->Int32?
      return fmt.locate( '$' )
endClass


class CmdNamedArg : Cmd
  PROPERTIES
    name           : String
    value          : Cmd
    is_negative    : Logical
    inferred_index : Int32?

  METHODS
    method init( t, name, value=null, is_negative=false )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->CmdNamedArg
      if (new_t) t = new_t
      return CmdNamedArg( t, name, clone(value), is_negative )

    method to->String
      return name

    method to_value->Cmd
      if (value)
        if (is_negative) throw t.error( "Invalid negation of a named parameter with a supplied value." )
        return value
      else
        if (is_negative) return CmdLiteralLogical( t, false )
        else             return CmdLiteralLogical( t, true )
      endIf
endClass

#------------------------------------------------------------------------------
# Access
#------------------------------------------------------------------------------
class CmdAccess : Cmd
  PROPERTIES
    context      : Cmd
    name         : String
    args         : CmdArgs
    named_args   : CmdNamedArg[]
    #debug : Logical

  METHODS
    method init( t, name )

    method init( t, name, args )

    method init( t, name, arg:Cmd )
      args = CmdArgs( arg )

    method init( t, name, args, named_args )

    method init( t, context, name )

    method init( t, context, name, args )

    method init( t, context, name, args, named_args )

    method init( t, context, name, arg:Cmd )
      args = CmdArgs()
      args.add( arg )

    method init( t, context_name:String, name )
      context = CmdAccess( t, context_name )

    method init( t, context_name:String, name, arg:Cmd )
      context = CmdAccess( t, context_name )
      args = CmdArgs( arg )

    method init( t, context_name:String, name, args )
      context = CmdAccess( t, context_name )

    method init( t, local_info:Local )
      init( t, local_info.name )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      local result = CmdAccess( t, clone(context,clone_args), name, clone(args,clone_args,new_t) )

      if (named_args)
        result.named_args = CmdNamedArg[]( named_args.count )
        forEach (named_arg in named_args) result.named_args.add( named_arg.cloned )
      endIf

      return result

    method is_scoped_read_access->Logical
      return true

    method eval (scope:Scope)->Value
      if (context?)
        scope = (context.eval(scope)->Object) as RoseObject # May need to do a proxy wrap here
        require(scope)
      endIf

      if (scope instanceOf RoseProxy and args)
        # Special handling for call of RoseProxy
        local proxy = scope as RoseProxy
        local vargs = Value[]
        forEach (arg in args)
          vargs.add(arg.eval(scope))
        endForEach
        return proxy.o.introspector.call(name, vargs)
      endIf

      local v = scope.getr(name, t)
      if (args)
        if (v instanceOf RoseObject)
          #TODO: named args
          local vargs = Value[]
          forEach (arg in args)
            vargs.add(arg.eval(scope))
          endForEach
          return ((v->Object) as RoseObject).call(scope, vargs)
        endIf
        require false
      endIf
      if (v is null) return NullValue
      if (v instanceOf Value) return v
      if (v instanceOf RoseObject) return ObjectValue(v)
      return ObjectValue(RoseProxy(v))

    method eval_assignment( scope:Scope, new_value:Cmd )->Value
      local rhs = new_value.eval(scope)
      if (context?)
        scope = (context.eval(scope)->Object) as RoseObject # May need to do a proxy wrap here
        require(scope)
      endIf
      if (args) throw t.error( "The result of a call cannot be assigned a value." )
      scope.set(name, rhs, &!force)
      return rhs

      #TODO: Lots more cases here, I think.  e.g., element access?

#{
    method resolve( scope:Scope )->Cmd
      return resolve( scope, false )

    method resolve( scope:Scope, ignore_question_mark:Logical )->Cmd
      if (args) args.resolve( scope )

      if (context?)
        if (not ignore_question_mark and name.ends_with('?'))
          return CmdLogicalize( t, CmdAccess(t,context,name.leftmost(-1),args) ).resolve( scope )
        endIf

        context = context.resolve( scope )

      else
        local v = scope.find_local( name )
        if (v)
          if (args) return CmdAccess( t, CmdAccess(t,context,name), "call", args ).resolve( scope )
          return CmdReadLocal(t,v).resolve(scope)
        endIf

        local new_type = scope.find_type( name.after_any('@') )
        if (new_type)
          # new TypeName(...)
          new_type.organize(scope)

          if (args is null)
            if (name.ends_with(']'))
              # Turn DataType[] -> DataType[]()
              args = CmdArgs()
            else
              return CmdReadSingleton( t, new_type )
            endIf
          endIf

          if (new_type.is_array)
            return CmdCreateArray( t, new_type, args ).resolve( scope )
          endIf

          if (new_type.is_compound)
            local cmd = scope.resolve_call( new_type, CmdAccess(t,"create",args,named_args), true )
            local cmd_call = cmd as CmdCall
            if (cmd_call and cmd_call.method_info.is_generated)
              # Calling the core compound creation routine
              return CmdCreateCompound( t, new_type, cmd_call.args ).resolve( scope )
            elseIf ( cmd_call)
              return cmd_call
            else
              return cmd
            endIf
          endIf

          local cmd_create = CmdCreateObject( t, new_type )
          local cmd_new = cmd_create : Cmd

          local cmd_call : Cmd
          if (new_type.is_native)
            cmd_call = scope.resolve_call( new_type,
            CmdAccess(t,CmdAccess(t,new_type.name),"create",args,named_args), true )
          else
            cmd_call = scope.resolve_call( new_type, CmdAccess(t,cmd_new,"init",args,named_args), true, Scope.SUPPRESS_INHERITED )
          endIf

          if (cmd_call)
            return cmd_call.cast_to( new_type, scope, &allow_implicit_narrowing ).resolve( scope )
          else
            return cmd_new.resolve(scope)
          endIf

        else
          if (not ignore_question_mark and name.ends_with('?'))
            return CmdLogicalize( t, CmdAccess(t,context,name.leftmost(-1),args) ).resolve( scope )
          endIf
        endIf

        # ---- No call context ----
        local result = scope.resolve_call( scope.this_type, this, false )
        if (result)
          check_for_recursive_getter( scope )
          return result
        endIf

        local p = scope.this_type.find_property( name )
        if (p)
          block
            if (args) return CmdAccess( t, CmdAccess(t,context,name), "call", args ).resolve( scope )

            if (scope.this_method.is_global)
              if (scope.this_type.find_global(name)) escapeBlock  # we'll get to the global later
              throw t.error( "Cannot access object property '$' from a global method." (name) )
            endIf
            context = CmdThisContext( t, scope.this_type )
            return CmdReadProperty( t, context, p )
          endBlock
        endIf

        p = scope.this_type.find_global( name )
        if (p)
          if (args) return CmdAccess( t, CmdAccess(t,context,name), "call", args ).resolve( scope )
          else      return CmdReadGlobal( t, p )
        endIf

        if (not args)
          local def = scope.this_type.definition_lookup[ name ]
          if (not def and scope.implicit_type) def = scope.implicit_type.definition_lookup[ name ]
          if (def) return def.expression.cloned(&new_t=t).resolve( scope )

          p = Program.type_Global.find_property( name )
          if (p)
            return CmdReadProperty( t, CmdReadSingleton(t,Program.type_Global), p ).resolve( scope )
          endIf

        endIf

        return scope.resolve_call( scope.this_type, this, true )
      endIf

      local context_type = context.require_type
      context_type.organize(scope)

      local result = scope.resolve_call( context_type, this, false )
      if (result) return result

      local p = context_type.find_property( name )
      if (p)
        block
          if (args) return CmdAccess( t, CmdAccess(t,context,name), "call", args ).resolve( scope )
          if (context.is_global)
            if (context_type.find_global(name)) escapeBlock
            throw t.error( "Cannot access object property '$' using a non-object context." (name) )
          endIf
          return CmdReadProperty( t, context, p )
        endBlock
      endIf

      p = context_type.find_global( name )
      if (p)
        if (args) return CmdAccess( t, CmdAccess(t,context,name), "call", args ).resolve( scope )
        context.require_type_context
        return CmdReadGlobal( t, p).resolve(scope)
      endIf

      if (not args)
        local def = context_type.definition_lookup[ name ]
        if (def)
          local old_implicit_type = scope.set_implicit_type( context_type )
          local def_result = def.expression.cloned(&new_t=t).resolve( scope )
          scope.set_implicit_type( old_implicit_type )
          return def_result
        endIf
      endIf

      return scope.resolve_call( context_type, this, true )

    method resolve_assignment( scope:Scope, new_value:Cmd )->Cmd
      if (args) throw t.error( "The result of a call cannot be assigned a value." )
      local setter_name = select(name[0]) { '@':null || "set_"+name } : String

      local context_was_null = context is null
      if (context is null)
        if (setter_name)
          local setter = scope.resolve_call( scope.this_type, CmdAccess(t,setter_name,CmdArgs(new_value)), false )
          if (setter)
            if (scope.this_method.name == setter_name)
              throw t.error( "Recursive call to setter set_" + name + "() - write \"@" + name + " = ...\" instead." )
            endIf
            return setter
          endIf
        endIf

        local as_type = scope.find_type( name )
        if (as_type and as_type.is_singleton)
          return CmdWriteSingleton( t, as_type, new_value ).resolve( scope )
        endIf

        local v = scope.find_local( name )
        if (v)
          return CmdWriteLocal(t,v,new_value).resolve(scope)
        endIf

        local def = scope.this_type.definition_lookup[ name ]
        if (not def and scope.implicit_type) def = scope.implicit_type.definition_lookup[ name ]
        if (def) return def.expression.cloned(&new_t=t).resolve_assignment( scope, new_value )

        local p = scope.this_method.type_context.find_global( name )
        if (p and (scope.this_method.is_global or not scope.this_method.type_context.find_property(name)))
          return CmdWriteGlobal( t, p, new_value ).resolve( scope )
        endIf

        if (scope.this_method.is_global)
          p = scope.this_method.type_context.find_property( name )
          if (p) throw t.error( "Cannot access object property '$' from a global method." (name) )
        endIf

        context = CmdThisContext( t, scope.this_type )
      else
        context = context.resolve( scope )
      endIf

      local context_type = context.require_type
      context_type.organize(scope)

      if (setter_name)
        local setter = scope.resolve_call( context_type, CmdAccess(t,context,setter_name,CmdArgs(new_value)), false )
        if (setter) return setter
      endIf

      local p = context_type.find_property( name )
      if (p)
        block
          if (context.is_global)
            if (context_type.find_global(name)) escapeBlock
            throw t.error( "Cannot access object property '$' from a non-object context." (name) )
          else
            return CmdWriteProperty( t, context, p, new_value ).resolve(scope)
          endIf
        endBlock
      endIf

      p = context_type.find_global( name )
      if (p)
        context.require_type_context
        return CmdWriteGlobal( t, p, new_value ).resolve(scope)
      endIf

      local def = context_type.definition_lookup[ name ]
      if (not def and scope.implicit_type) def = scope.implicit_type.definition_lookup[ name ]
      if (def) return def.expression.cloned(&new_t=t).resolve_assignment( scope, new_value )

      if (context_was_null and scope.this_type is not Program.type_Global)
        p = Program.type_Global.find_property( name )
        if (p)
          return CmdWriteProperty( t, CmdReadSingleton(t,Program.type_Global), p, new_value ).resolve( scope )
        endIf
      endIf

      if (setter_name)
        local setter = scope.resolve_call( context_type, CmdAccess(t,context,setter_name,CmdArgs(new_value)), true )
        if (setter) return setter
      endIf

      throw t.error( ''No such method or variable "$" exists in the current scope.'' (name) )

    method expand_modify_and_assign( scope:Scope, op:TokenType, new_value:Cmd )->Cmd
      local cmd : Cmd
      which (op)
        case TokenType.symbol_ampersand_equals:    cmd = CmdBitwiseAnd( t, this, new_value )
        case TokenType.symbol_caret_equals:        cmd = CmdPower( t, this, new_value )
        case TokenType.symbol_dot_equals:          cmd = CmdAccess( t, this, name, new_value )
        case TokenType.symbol_minus_equals:        cmd = CmdSubtract( t, this, new_value )
        case TokenType.symbol_percent_equals:      cmd = CmdMod( t, this, new_value )
        case TokenType.symbol_plus_equals:         cmd = CmdAdd( t, this, new_value )
        case TokenType.symbol_slash_equals:        cmd = CmdDivide( t, this, new_value )
        case TokenType.symbol_tilde_equals:        cmd = CmdBitwiseXor( t, this, new_value )
        case TokenType.symbol_times_equals:        cmd = CmdMultiply( t, this, new_value )
        case TokenType.symbol_vertical_bar_equals: cmd = CmdBitwiseOr( t, this, new_value )
        others
          @trace
          throw t.error( "[INTERNAL]" )
      endWhich
      return CmdAssign( t, this.cloned, cmd )

    method resolve_modify_and_assign( scope:Scope, op:TokenType, new_value:Cmd )->Cmd
      local context_type : Type

      if (context)
        context = context.resolve( scope )
        context_type = context.require_type
      else
        if (args is null)
          local v = scope.find_local( name )
          if (v)
            if (args) throw t.error( "Local variable '$' cannot be called like a method."(name) )
            return CmdModifyAndAssignLocal(t,v,op,new_value).resolve(scope)
          endIf
        endIf

        context_type = scope.this_type

      endIf

      local setter_name : String
      if (name[0] != '@')
        setter_name = "set_" + name
        local setter = scope.resolve_call( context_type, CmdAccess(t,setter_name,CmdArgs(new_value)), false )
        if (setter)
          return expand_modify_and_assign( scope, op, new_value ).resolve( scope )
        endIf
      endIf

      local p = context_type.find_property( name )
      if (p)
        block
          local new_context = context
          if (not new_context) new_context = CmdThisContext( t, context_type )
          if (new_context.is_global and scope.this_method.is_global)
            if (context_type.find_global(name)) escapeBlock
            throw t.error( "Cannot access object property '$' from a global method." (name) )
          endIf
          context = new_context
          return CmdModifyAndAssignProperty( t, context, p, op, new_value ).resolve(scope)
        endBlock
      endIf

      p = context_type.find_global( name )
      if (p)
        if (context) context.require_type_context
        return CmdModifyAndAssignGlobal( t, p, op, new_value ).resolve(scope)
      endIf

      local def = context_type.definition_lookup[ name ]
      if (not def and scope.implicit_type) def = scope.implicit_type.definition_lookup[ name ]
      if (def) return def.expression.cloned(&new_t=t).resolve_modify_and_assign( scope, op, new_value )

      if (setter_name)
        local setter = scope.resolve_call( context_type, CmdAccess(t,setter_name,CmdArgs(new_value)), true )
        if (setter) return expand_modify_and_assign( scope, op, new_value ).resolve( scope )
      endIf

      throw t.error( ''No such method or variable "$" exists in the current scope.'' (name) )
}#

    method to->String
      local buffer = StringBuilder()
      buffer.print( "CmdAccess(" )
      if (context) buffer.print( context ).print( "," )
      buffer.print( '"' ).print( name ).print( '"' )
      if (args) buffer.print( args )
      if (named_args) buffer.print( '&' ).print( named_args )
      buffer.print( ")" )
      return buffer->String
endClass


class CmdElementAccess : Cmd
  PROPERTIES
    context : Cmd
    index   : Cmd

  METHODS
    method init( t, context, index )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdElementAccess( t, context.cloned( clone_args, new_t ), index.cloned( clone_args, new_t ) )

    method is_scoped_read_access->Logical
      return true

    method eval( scope:Scope )->Value
      local ctxt = context.eval( scope )

      if (ctxt instanceOf ValueList)
        return ctxt[index.eval(scope)->Int32]
      elseIf (ctxt instanceOf ValueTable)
        return ctxt[index.eval(scope)->String]
      elseIf (ctxt.is_object and ctxt->Object instanceOf RoseProxy)
        # Special handling
        local proxy = (ctxt->Object) as RoseProxy
        return proxy.o.introspector.call("get", @[index.eval(scope)])
      else
        local args = CmdArgs()
        args.add( index )
        return CmdAccess(t, context, "get", args).eval(scope)
      endIf

    method eval_assignment( scope:Scope, new_value:Cmd )->Value

      local ctxt = context.eval( scope )

      if (ctxt instanceOf ValueList)
        local rhs = new_value.eval(scope)
        ctxt[index.eval(scope)->Int32] = rhs
        return rhs
      elseIf (ctxt instanceOf ValueTable)
        local rhs = new_value.eval(scope)
        ctxt[index.eval(scope)->String] = rhs
        return rhs
      elseIf (ctxt.is_object and ctxt->Object instanceOf RoseProxy)
        # Special handling
        local rhs = new_value.eval(scope)
        local proxy = (ctxt->Object) as RoseProxy
        proxy.o.introspector.call("set", @[index.eval(scope), rhs])
        return rhs
      else
        local args = CmdArgs()
        args.add( index )
        args.add( new_value )
        return CmdAccess(t, context, "set", args).eval(scope)
      endIf
#{
    method resolve_assignment( scope:Scope, new_value:Cmd )->Cmd
      context = context.resolve( scope )

      local context_type = context.require_type
      context_type.organize(scope)
      if (context_type.is_array)
        return CmdWriteArrayElement( t, context, index, new_value ).resolve( scope )
      else
        local args = CmdArgs()
        args.add( index ).add( new_value )
        local result = scope.resolve_call( context_type, CmdAccess(t,context,"set",args), true )
        return result
      endIf

    method resolve_modify_and_assign( scope:Scope, op:TokenType, new_value:Cmd )->Cmd
      local cmd : Cmd
      which (op)
        case TokenType.symbol_ampersand_equals:    cmd = CmdBitwiseAnd( t, this, new_value )
        case TokenType.symbol_caret_equals:        cmd = CmdPower( t, this, new_value )
        #case TokenType.symbol_dot_equals:          cmd = CmdAccess( t, this, name, new_value )
        case TokenType.symbol_minus_equals:        cmd = CmdSubtract( t, this, new_value )
        case TokenType.symbol_percent_equals:      cmd = CmdMod( t, this, new_value )
        case TokenType.symbol_plus_equals:         cmd = CmdAdd( t, this, new_value )
        case TokenType.symbol_slash_equals:        cmd = CmdDivide( t, this, new_value )
        case TokenType.symbol_tilde_equals:        cmd = CmdBitwiseXor( t, this, new_value )
        case TokenType.symbol_times_equals:        cmd = CmdMultiply( t, this, new_value )
        case TokenType.symbol_vertical_bar_equals: cmd = CmdBitwiseOr( t, this, new_value )
        others
          @trace
          throw t.error( "[INTERNAL]" )
      endWhich
      return CmdAssign( t, this.cloned, cmd ).resolve( scope )

    method resolve_adjust( scope:Scope, delta:Int32 )->Cmd
      return cloned.resolve_assignment( scope, CmdAdd(t,this,CmdLiteralInt32(t,delta)) )
}#
    method to->String
      return "$[$]" (context,index)

endClass

#{

#------------------------------------------------------------------------------
# Object Creation
#------------------------------------------------------------------------------
class CmdCreateObject : Cmd
  PROPERTIES
    of_type       : Type

  METHODS
    method init( t, of_type )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCreateObject( t, of_type )

    method resolve( scope:Scope )->Cmd
      of_type.organize(scope)
      return this

    method to->String
      return of_type + "()"

    method type->Type
      return of_type
endClass


class CmdCreateCompound : Cmd
  PROPERTIES
    of_type : Type
    args    : CmdArgs

  METHODS
    method init( t, of_type, args )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCreateCompound( t, of_type, args.cloned( clone_args, new_t ) )

    method resolve( scope:Scope )->Cmd
      of_type.organize(scope)
      ensure args

      local non_native_property_count = 0
      forEach (p in of_type.property_list)
        if (not p.is_native) ++non_native_property_count
      endForEach

      local i = args.count
      while (args.count < non_native_property_count)
        local p = of_type.property_list[i]
        if (not p.is_native)
          if (p.initial_value)
            args.add( p.initial_value.cloned.resolve(scope) )
          else
            args.add( p.type.create_default_value(t) )
          endIf
        endIf
        ++i
      endWhile

      args.resolve( scope )
      return this

    method type->Type
      return of_type
endClass
}#

#------------------------------------------------------------------------------
# Assign
#------------------------------------------------------------------------------
class CmdAssign : Cmd
  PROPERTIES
    target    : Cmd
    new_value : Cmd

  METHODS
    method init( t, target, new_value )

    method init( t, local_info:Local, new_value )
      target = CmdAccess( t, local_info.name )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdAssign( t, target.cloned( clone_args, new_t ), new_value.cloned( clone_args, new_t ) )

    method eval( scope:Scope )->Value
      return target.eval_assignment( scope, new_value )

    method to->String
      return "CmdAssign($ = $)" (target,new_value)
endClass
#{

#------------------------------------------------------------------------------
# Read/Write
#------------------------------------------------------------------------------

class CmdThisContext : Cmd
  PROPERTIES
    this_type : Type

  METHODS
    method init( t, this_type )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      local macro_args = (clone_args as MacroArgs)
      if (macro_args) return macro_args.inline_this

      local task_args = (clone_args as TaskArgs)
      if (task_args)
        return task_args.cmd_read_context(t)
      else
        return CmdThisContext( t, this_type )
      endIf

    method implicit_type( scope:Scope )->Type
      return this_type

    method is_scoped_read_access->Logical
      return true


    method require_type_context
      noAction

    method resolve( scope:Scope )->Cmd
      this_type.organize(scope)
      return this

    method type->Type
      return this_type
endClass

class CmdLiteralThis : CmdThisContext
  PROPERTIES
    this_type : Type

  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      local macro_args = (clone_args as MacroArgs)
      if (macro_args) return macro_args.inline_this

      local task_args = (clone_args as TaskArgs)
      if (task_args)
        return task_args.cmd_read_context(t)
      else
        return CmdLiteralThis( t, this_type )
      endIf

    method require_type_context
      throw t.error( "Type name expected." )

    method resolve( scope:Scope )->Cmd
      this_type.organize(scope)
      if (scope.this_method.is_global)
        throw t.error( "Invalid reference to 'this' object - global methods have no object context." )
      endIf
      return this

    method to->String
      return "this<<$>>" (this_type)
endClass
}#


class CmdReadLocal : Cmd
  PROPERTIES
    local_info : Local

  METHODS
    method init( t, local_info )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
#      local macro_args = (clone_args as MacroArgs)
#      if (macro_args)
#        return macro_args.inline_read_local( this )
#      else
#        local task_args = (clone_args as TaskArgs)
#        if (task_args)
#          return task_args.cmd_read(t,local_info)
#        endIf
#      endIf

      return CmdReadLocal( t, local_info )

    method is_scoped_read_access->Logical
      return true

    method eval( scope:Scope )->Value
      #trace local_info.type, local_info.name, scope.this_method.name, scope.this_type.name
      return scope.getr(local_info.name)

#    method resolve_adjust( scope:Scope, delta:Int32 )->Cmd
#      return CmdAdjustLocal( t, local_info, delta ).resolve( scope )

    method to->String
      return 'CmdReadLocal("$")' (local_info.original_name)

endClass


#{
class CmdWriteLocal : Cmd
  PROPERTIES
    local_info : Local
    new_value  : Cmd

  METHODS
    method init( t, local_info, new_value )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      local macro_args = (clone_args as MacroArgs)
      if (macro_args)
        return macro_args.inline_write_local( this )
      else
        local task_args = (clone_args as TaskArgs)
        if (task_args)
          return task_args.cmd_write( t,local_info, new_value.cloned( clone_args, new_t ) )
        endIf
      endIf
      return CmdWriteLocal( t, local_info, clone(new_value,clone_args,new_t) )

    method resolve( scope:Scope )->Cmd
      local_info.type.organize(scope)
      local_info.is_modified = true
      new_value = new_value.resolve(scope)
      new_value = new_value.cast_to( local_info.type, scope ).resolve( scope )
      return this

endClass


class CmdReadGlobal : Cmd
  PROPERTIES
    global_info : Property

  METHODS
    method init( t, global_info )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdReadGlobal( t, global_info )

    method resolve( scope:Scope )->Cmd
      global_info.type_context.resolve
      return this

    method resolve_adjust( scope:Scope, delta:Int32 )->Cmd
      return CmdAdjustGlobal( t, global_info, delta ).resolve( scope )

    method type->Type
      return global_info.type
endClass


class CmdWriteGlobal : Cmd
  PROPERTIES
    global_info  : Property
    new_value     : Cmd

  METHODS
    method init( t, global_info, new_value )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdWriteGlobal( t, global_info, new_value.cloned( clone_args, new_t ) )

    method resolve( scope:Scope )->Cmd
      new_value = new_value.resolve(scope).cast_to( global_info.type, scope ).resolve( scope )
      return this

endClass

class CmdReadProperty : Cmd
  PROPERTIES
    context       : Cmd
    property_info : Property

  METHODS
    method init( t, context, property_info )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdReadProperty( t, context.cloned( clone_args, new_t ), property_info )

    method is_scoped_read_access->Logical
      return true

    method resolve( scope:Scope )->Cmd
      context = context.resolve( scope ).require_value
      if (context.type.is_aspect)
        throw t.error( "Cannot read properties using aspect references.  Add a getter to the aspect definition - " +
          "'method $->$: return @$'."  (property_info.name,property_info.type.name,property_info.name) )
      endIf
      return this

    method resolve_adjust( scope:Scope, delta:Int32 )->Cmd
      local setter_name = "set_" + property_info.name
      local getter_name = property_info.name
      local context_type = context.type
      if (context_type.has_method_named(setter_name) or context_type.has_method_named(getter_name))
        return CmdAssign( t, CmdAccess(t,context,property_info.name), CmdAdd(t,CmdAccess(t,context.cloned,property_info.name),CmdLiteralInt32(t,delta)) ).resolve( scope )
      endIf
      return CmdAdjustProperty( t, context, property_info, delta ).resolve( scope )

    method to->String
      return "$.$" (context,property_info)

    method type->Type
      return property_info.type
endClass


class CmdWriteProperty : Cmd
  PROPERTIES
    context       : Cmd
    property_info : Property
    new_value     : Cmd

  METHODS
    method init( t, context, property_info, new_value )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdWriteProperty( t, context.cloned( clone_args, new_t ), property_info, new_value.cloned( clone_args, new_t ) )

    method resolve( scope:Scope )->Cmd
      context = context.resolve(scope).require_value

      if (context.type.is_aspect)
        throw t.error( "Cannot write properties using aspect references.  Add a setter to the aspect definition - " +
          "'method set_$(@$)'." (property_info.name,property_info.name) )
      endIf

      new_value = new_value.resolve(scope).require_value.cast_to( property_info.type, scope ).resolve( scope )
      return this

    method to->String
      return "CmdWriteProperty($ = $)" (context,new_value)

endClass

#------------------------------------------------------------------------------
# Method Calls
#------------------------------------------------------------------------------
class CmdCall : Cmd
  PROPERTIES
    context     : Cmd
    method_info : Method
    args        : CmdArgs

  METHODS
    method init( t, context, method_info, args )
      if (context and context.is_global and not method_info.is_global)
        throw t.error( "Cannot call object method $.$ on a non-object." (method_info.type_context,method_info.signature) )
      endIf

    method is_scoped_read_access->Logical
      return true

    method require_type->Type
      local result = type
      if (result is null)
        throw t.error( "Value expected; call to $.$ does not return a value." (method_info.type_context,method_info.signature) )
      endIf
      return result

    method resolve( scope:Scope )->Cmd
      if (context) context = context.resolve(scope).require_value
      args.resolve( scope )
      return this

    method resolve_adjust( scope:Scope, delta:Int32 )->Cmd
      if (not method_info.return_type)
        throw t.error( "Method '$' does not return a value." (method_info.signature) )
      endIf

      if (method_info.name == "get")
        # Pass back the same args plus our new value
        ensure args
        local setter_args = args.cloned
        setter_args.add( CmdAdd(t,this,CmdLiteralInt32(t,delta)) )
        if (context)
          return CmdAccess( t, context.cloned, "set", setter_args ).resolve(scope)
        else
          return CmdAccess( t, "set", setter_args ).resolve(scope)
        endIf
      else
        # Transform get_name() into set_name(new_value)
        local setter_name = "set_" + method_info.name
        local setter_args = select{ args:args.cloned || CmdArgs() }
        setter_args.add( CmdAdd(t,this,CmdLiteralInt32(t,delta)) )
        if (context)
          return CmdAccess( t, context.cloned, setter_name, setter_args ).resolve(scope)
        else
          return CmdAccess( t, setter_name, setter_args ).resolve(scope)
        endIf
      endIf

    method type->Type
      return method_info.return_type
endClass


class CmdCallRoutine : CmdCall
  METHODS
    method init( t, method_info, args )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCallRoutine( t, method_info, args.cloned( clone_args, new_t ) )

    method to->String
      return "CmdCallRoutine($.$,$)" (method_info.type_context,method_info.signature,args)
endClass

class CmdCallAspectMethod : CmdCall
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCallAspectMethod( t, clone(context,clone_args,new_t), method_info, args.cloned( clone_args, new_t ) )

endClass


class CmdCallMethod : CmdCall
  METHODS
    method call_prior( scope:Scope )->Cmd
      if (method_info.is_initializer and method_info.type_context is not scope.this_type)
        # Calling a prior initializer with a different signature that was hidden by
        # an extended class initializer.
        return CmdCallStaticMethod( t, context, method_info, args )
      endIf

      if (not method_info.overridden_method)
        if (method_info.specializer_count and method_info.type_context.base_class)
          # This method conforms to a method template syntax.  Attempt to instantiate
          # the corresponding method template in the base class.  If successful it
          # will change method_info.overridden_method.
          method_info.type_context.base_class.method_templates.instantiate( method_info.unspecialized_name,
              method_info.specializer_count, t, method_info.name, null )
        endIf

        if (not method_info.overridden_method)
          throw t.error( "Cannot call prior.$ from class $ because the method is not an override - no prior version of it exists." (method_info.signature,method_info.type_context) )
        endIf
      endIf

      return CmdCallStaticMethod( t, context, method_info.overridden_method, args )
endClass

class CmdCallDynamicMethod : CmdCallMethod
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCallDynamicMethod( t, clone(context,clone_args,new_t), method_info, args.cloned( clone_args, new_t ) )


    method to->String
      return "CmdCallDynamicMethod($.$,$,$)->$" (method_info.type_context,method_info.signature,context,args,method_info.return_type)
endClass


class CmdCallStaticMethod : CmdCallMethod
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCallStaticMethod( t, clone(context,clone_args,new_t), method_info, args.cloned( clone_args, new_t ) )

    method resolve( scope:Scope )->Cmd
      if (not context) context = CmdThisContext(t,method_info.type_context)
      return prior.resolve( scope )

    method to->String
      return "CmdCallStaticMethod($.$,$)" (method_info.type_context,method_info.signature,args)
endClass


class CmdCallPriorMethod : Cmd
  PROPERTIES
    name       : String
    args       : CmdArgs
    named_args : CmdNamedArg[]

  METHODS
    method init( t, name, args, named_args )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      local cloned_named_args : CmdNamedArg[]
      if (named_args)
        cloned_named_args = CmdNamedArg[]( named_args.count )
        forEach (named_arg in named_args) cloned_named_args.add( named_arg.cloned )
      endIf
      return CmdCallPriorMethod( t, name, clone(args,clone_args,new_t), cloned_named_args )

    method is_scoped_read_access->Logical
      return true

    method resolve( scope:Scope )->Cmd
      local access = CmdAccess( t, name, args, named_args )
      if (name == "init")
        local call = scope.resolve_call( scope.this_type, access, &error_on_fail, Scope.CALLING_PRIOR_INIT )
        return call.call_prior( scope )

      else
        local call = scope.resolve_call( scope.this_type, access, &error_on_fail )
        return call.call_prior( scope )
      endIf
endClass


class CmdCallNativeRoutine : CmdCall
  METHODS
    method init( t, method_info, args )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCallNativeRoutine( t, method_info, args.cloned( clone_args, new_t ) )

endClass

class CmdCallNativeMethod : CmdCall
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCallNativeMethod( t, clone(context,clone_args,new_t), method_info, args.cloned( clone_args, new_t ) )

endClass

class CmdCallInlineNative : CmdCall
  PROPERTIES
    adjust_delta : Int32

  METHODS
    method to->String
      return method_info.signature

    method resolve_adjust( scope:Scope, adjust_delta )->Cmd
      return this

    method resolve( scope:Scope )->Cmd
      if (method_info.native_return_type) method_info.native_return_type.organize(scope)
      return this
endClass

class CmdCallInlineNativeRoutine : CmdCallInlineNative
  METHODS
    method init( t, method_info, args )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCallInlineNativeRoutine( t, method_info, args.cloned( clone_args, new_t ) )

    method type->Type
      return method_info.return_type
endClass

class CmdCallInlineNativeMethod : CmdCallInlineNative
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCallInlineNativeMethod( t, clone(context,clone_args,new_t), method_info, args.cloned( clone_args, new_t ) )

    method type->Type
      return method_info.return_type
endClass
}#

#------------------------------------------------------------------------------
# Miscellaneous Expressions
#------------------------------------------------------------------------------
class CmdRange : Cmd
  PROPERTIES
    first : Cmd
    last  : Cmd
    step_size  : Cmd

  METHODS
    method init( t, first, last, step_size=null )

    method default_step_size->Int32
      return 1

    method step_cmd->Cmd
      if (step_size) return step_size
      return CmdLiteralInt32( t, default_step_size )

    method eval( scope:Scope )->Value
      local f = first.eval( scope )
      local l = last.eval( scope )
      local ss = default_step_size
      if (step_size)
        ss = step_size.eval(scope)->Int32
        if (ss == 0) throw t.error("Step size of 0 is invalid")
      endIf
      return Range<<Int32>>(f,l,ss)

endClass

class CmdRangeUpTo : CmdRange
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdRangeUpTo( t, first.cloned( clone_args, new_t ), last.cloned( clone_args, new_t ), clone(step_size,clone_args,new_t) )

    method eval( scope:Scope )->Value
      local f = first.eval( scope )->Int32
      local l = last.eval( scope )->Int32
      local ss = default_step_size
      if (step_size)
        ss = step_size.eval(scope)->Int32
        if (ss == 0) throw t.error("Step size of 0 is invalid")
      endIf
      return RangeToLimit<<Int32>>(f,l,ss)
endClass

#{
class CmdRangeUpToLessThan : CmdRange
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdRangeUpToLessThan( t, first.cloned( clone_args, new_t ), last.cloned( clone_args, new_t ), clone(step_size,clone_args,new_t) )
endClass

class CmdRangeDownTo : CmdRange
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdRangeDownTo( t, first.cloned( clone_args, new_t ), last.cloned( clone_args, new_t ), clone(step_size,clone_args,new_t) )

    method default_step_size->Int32
      return -1
endClass

class CmdTuple : Cmd
  PROPERTIES
    elements   : Cmd[]
    synthesize_variables : Logical
    # If above is true, this is a tuple for destructuring assignment and we should
    # synthesize the variables (e.g., it was done with "local (a,b) = (1,2)").

  METHODS
    method init( t, elements, synthesize_variables=false )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->this
      if (new_t) t = new_t
      return CmdTuple( t, elements.cloned, synthesize_variables )

    method resolve( scope:Scope )->Cmd
      local args = CmdArgs()
      local type_string = ""
      forEach (el at i in elements)
        if (el instanceOf CmdNoAction )
          # CmdNoAction is used as a placeholder for elements that are to be
          # skipped when doing destructuring assignment, and is illegal for
          # value tuples.  We could use them for doing Python-style
          # single-element tuples: "(1,)", but we don't presently.
          throw el.t.error("Expected a value, but got '$'." (el.t))
        endIf
        elements[i] = el.resolve( scope )
        elements[i].require_type.organize( scope )
        elements[i] = elements[i].require_value
        args.add(elements[i])
        if (i > 0) type_string += ","
        type_string += elements[i].type.name
      endForEach
      return CmdAccess( t, "Tuple<<$>>"(type_string), args ).resolve( scope )

    method _get_element_type ( rht:Type, index:Int32 ) -> Type
        local prop = rht.find_property("_$" (1+index))
        if (prop) return prop.type
        local meth = rht.find_method("_$()" (1+index))
        if (meth) return meth.return_type
        return null

    method _create_variables ( scope:Scope, rht:Type )
      forEach (el at el_index in elements)
        if (el instanceOf CmdNoAction) nextIteration # They are skipping this one
        local type = _get_element_type(rht, el_index)
        if (el instanceOf CmdTuple)
          # synthesizing for nested destructuring
          (el as CmdTuple)._create_variables(scope, type)
          nextIteration
        endIf
        require(el instanceOf CmdAccess)
        local part_var = scope.this_method.add_local( t, (el as CmdAccess).name, type )
        local part_decl = CmdLocalDeclaration(t,part_var)
        scope.this_body.add( part_decl.resolve(scope) )
      endForEach

    method resolve_assignment( scope:Scope, new_value:Cmd )->Cmd
      new_value = new_value.resolve(scope)
      local rht = new_value.require_type # Type of right-hand tuple
      rht.organize(scope)

      if (rht.is_tuple)
        require(rht.property_list.count >= rht.specializers.count)
        if (rht.specializers.count != elements.count)
          throw t.error("Cannot assign $ elements because the right-hand tuple has $." (elements.count, rht.specializers.count))
        endIf
      else
        # Maybe it supports something vaguely tuple-like.  Let's check...
        # This doesn't support semi-odd things like "method _1(param=false)->t" which could
        # theoretically work.
        forEach (el_index in 0..<elements.count)
          if (_get_element_type(rht, el_index) == null)
            throw t.error("Cannot assign $ elements because the right-hand side has $." (elements.count, el_index))
          endIf
        endForEach
        if (_get_element_type(rht, elements.count))
          throw t.error("Cannot assign $ elements because the right-hand side has more than that." (elements.count))
        endIf
      endIf

      # We assign the RHS to a temporary variable inside a block.
      # Inside the block, we assign elements of the temporary to the individual
      # variables.
      # By having the temporary inside a block, it gets destroyed right after
      # all the assignments, which lets the temporary expire at the correct
      # time.  This may be important for garbage collection, for example.
      # Since the temporary and assignments are inside a block, if we are
      # synthesizing variables, we need to do it in the current scope first.

      if (synthesize_variables) _create_variables(scope, rht)

      local temp_block = CmdBlock( t )

      local temp_var = scope.this_method.add_local( t, Program.create_unique_id, null, new_value )
      local temp_var_decl = CmdLocalDeclaration(t,temp_var)
      temp_block.statements.add( temp_var_decl )

      forEach (el at el_index in elements)
        if (el instanceOf CmdNoAction) nextIteration # They are skipping this one
        local rhs_part = CmdAccess(t, CmdAccess(t, temp_var), "_"+(el_index+1))
        temp_block.statements.add( CmdAssign(t, el, rhs_part) )
      endForEach

      scope.this_body.add( temp_block.resolve(scope) )
      return CmdNoAction(t)
endClass
}#

#------------------------------------------------------------------------------
# Unary Operators
#------------------------------------------------------------------------------
class CmdUnary : Cmd
  PROPERTIES
    operand : Cmd

  METHODS
    method init( t, operand )

    method prefix_symbol->String
      return ""

    method fn_name->String
      return null

    method eval( scope:Scope )->Value
      return operation(operand.eval( scope ))

    method suffix_symbol->String
      return ""

    method operation ( value:Value )->Value
      throw t.error( "[INTERNAL] $ is not defined." (type_name) )

    method to->String
      return "$($)" (type_name,operand)
endClass

class CmdLogicalize : CmdUnary
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdLogicalize( t, operand.cloned( clone_args, new_t ) )

    method fn_name->String
      return "operator?"

    method prefix_symbol->String
      return ""

    method suffix_symbol->String
      return "?"

endClass

class CmdLogicalNot : CmdUnary
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdLogicalNot( t, operand.cloned( clone_args, new_t ) )

    method prefix_symbol->String
      return "not "

    method eval(scope:Scope)->Value
      return not operand.eval(scope)
endClass


class CmdNegate : CmdUnary
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdNegate( t, operand.cloned( clone_args, new_t ) )

    method fn_name->String
      return "operator-"

    method prefix_symbol->String
      return "(-"

    method suffix_symbol->String
      return ")"

    method eval(scope:Scope)->Value
      return -operand.eval(scope)
endClass


#------------------------------------------------------------------------------
# Binary Operators
#------------------------------------------------------------------------------
class CmdBinary : Cmd
  PROPERTIES
    left   : Cmd
    right  : Cmd

  METHODS
    method init( t, left, right )

    method fn_name->String
      throw t.error( "[INTERNAL] $.fn_name() is not defined." (type_name) )

    method requires_parens->Logical
      return true

    method eval( scope:Scope )->Value
      return operation(left.eval(scope), right.eval(scope))

    method operation (l:Value, r:Value)->Value
      throw t.error( "[INTERNAL] $ is not defined." (type_name) )

    method symbol->String
      throw t.error( "[INTERNAL] $.symbol() is not defined." (type_name) )

    method to->String
      return "$($,$)" (type_name,left,right)
endClass

class CmdAdd : CmdBinary
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdAdd( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method fn_name->String
      return "operator+"

    method symbol->String
      return "+"

    method operation (l:Value, r:Value)->Value
      return l + r
endClass


class CmdSubtract : CmdBinary
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdSubtract( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method fn_name->String
      return "operator-"

    method symbol->String
      return "-"

    method operation (l:Value, r:Value)->Value
      return l - r
endClass

class CmdMultiply : CmdBinary
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdMultiply( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method fn_name->String
      return "operator*"

    method symbol->String
      return "*"

    method operation (l:Value, r:Value)->Value
      return l * r
endClass


class CmdDivide : CmdBinary
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdDivide( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method fn_name->String
      return "operator/"

    method symbol->String
      return "/"

    method operation (l:Value, r:Value)->Value
      return l / r
endClass


class CmdMod : CmdBinary
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdMod( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method fn_name->String
      return "operator%"

    method symbol->String
      return "%"
endClass


class CmdPower : CmdBinary
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdPower( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method fn_name->String
      return "operator^"

    method symbol->String
      return "^"
endClass


class CmdBinaryLogical : CmdBinary
  METHODS
    method combine_literal_operands( a:Logical, b:Logical )->Logical
      throw t.error( "[INTERNAL] $.combine_literal_operands(Logical,Logical) is not defined." (type_name) )

endClass

class CmdLogicalAnd : CmdBinaryLogical
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdLogicalAnd( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method symbol->String
      return "and"
endClass


class CmdLogicalOr : CmdBinaryLogical
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdLogicalOr( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method symbol->String
      return "or"
endClass



class CmdLogicalXor : CmdBinaryLogical
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdLogicalXor( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method requires_parens->Logical
      return true

    method symbol->String
      return "xor"
endClass


#------------------------------------------------------------------------------
# Comparison Operators
#------------------------------------------------------------------------------
class CmdComparison : CmdBinary
  PROPERTIES
    resolved : Logical

  METHODS
    method requires_parens->Logical
      return false

endClass

class CmdCompareEQ : CmdComparison
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCompareEQ( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method requires_parens->Logical
      return false

    method symbol->String
      return "=="

    method operation (l:Value, r:Value)->Value
      return l == r
endClass

class CmdCompareNE : CmdComparison
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCompareNE( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method symbol->String
      return "!="

    method operation (l:Value, r:Value)->Value
      return l != r
endClass

class CmdCompareLT : CmdComparison
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCompareLT( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method symbol->String
      return "<"

    method operation (l:Value, r:Value)->Value
      return l < r
endClass

class CmdCompareLE : CmdComparison
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCompareLE( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method symbol->String
      return "<="

    method operation (l:Value, r:Value)->Value
      return l <= r
endClass

class CmdCompareGT : CmdComparison
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCompareGT( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method symbol->String
      return ">"

    method operation (l:Value, r:Value)->Value
      return l > r
endClass

class CmdCompareGE : CmdComparison
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCompareGE( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method symbol->String
      return ">="

    method operation (l:Value, r:Value)->Value
      return l >= r
endClass

class CmdCompare : CmdComparison
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCompare( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method symbol->String
      return "<>"
endClass

class CmdCompareIs : CmdComparison
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCompareIs( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method symbol->String
      return "is"

    method operation (l:Value, r:Value)->Value
      if (l is r) return true
      if (l.is_object and r.is_object and l->Object is r->Object) return true
      return false

endClass

class CmdCompareIsNot : CmdComparison
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCompareIsNot( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method symbol->String
      return "is not"

    method operation (l:Value, r:Value)->Value
      if (l is r) return false
      if (l.is_object and r.is_object and l->Object is r->Object) return false
      return true
endClass

#------------------------------------------------------------------------------
# Bitwise
#------------------------------------------------------------------------------
class CmdBitwiseOp : CmdBinary
  METHODS
endClass

class CmdBitwiseAnd : CmdBitwiseOp
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdBitwiseAnd( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method fn_name->String
      return "operator&"

    method symbol->String
      return "&"
endClass

class CmdBitwiseOr : CmdBitwiseOp
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdBitwiseOr( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method fn_name->String
      return "operator|"

    method symbol->String
      return "|"
endClass

class CmdBitwiseXor : CmdBitwiseOp
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdBitwiseXor( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method fn_name->String
      return "operator~"

    method requires_parens->Logical
      return true

    method symbol->String
      return "~"
endClass

class CmdBitwiseShiftLeft : CmdBitwiseOp
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdBitwiseShiftLeft( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method fn_name->String
      return "operator:<<:"

    method symbol->String
      return ":<<:"
endClass

class CmdBitwiseShiftRight : CmdBitwiseOp
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdBitwiseShiftRight( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method fn_name->String
      return "operator:>>:"

    method symbol->String
      return ":>>:"
endClass

class CmdBitwiseShiftRightX : CmdBitwiseOp
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdBitwiseShiftRightX( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method fn_name->String
      return "operator:>>>:"

    method symbol->String
      return ":>>>:"
endClass


class CmdBitwiseNot : CmdUnary
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdBitwiseNot( t, operand.cloned( clone_args, new_t ) )

    method fn_name->String
      return "operator!"

    method prefix_symbol->String
      return "!"
endClass

#------------------------------------------------------------------------------
# adjust
#------------------------------------------------------------------------------
class CmdAdjust : Cmd
  PROPERTIES
    operand : Cmd
    delta   : Int32

  METHODS
    method init( t, operand, delta )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdAdjust( t, operand.cloned( clone_args, new_t ), delta )

    method is_scoped_read_access->Logical
      return true

    method eval( scope:Scope )->Value
      local op = operand.eval( scope )
      return op.eval_adjust( scope, delta )
endClass

class CmdAdjustLocal : Cmd
  PROPERTIES
    local_info : Local
    delta      : Int32

  METHODS
    method init( t, local_info, delta )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      #local task_args = (clone_args as TaskArgs)
      #if (task_args)
      #  return CmdAdjust( t, CmdAccess(t, task_args.cmd_read_this(t), task_args.convert_local_name(local_info)), delta )
      #else
        return CmdAdjustLocal( t, local_info, delta )
      #endIf

    method is_scoped_read_access->Logical
      return true

    method to->String
      return "CmdAdjustLocal($)" (local_info.name)

    method eval( scope:Scope )->Value
      local v = scope.getv(local_info.name) + delta
      scope.set(local_info.name, v)
      return v
endClass

#{
class CmdAdjustProperty : Cmd
  PROPERTIES
    context       : Cmd
    property_info : Property
    delta         : Int32

  METHODS
    method init( t, context, property_info, delta )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdAdjustProperty( t, context.cloned( clone_args, new_t ), property_info, delta )

    method is_scoped_read_access->Logical
      return true

    method resolve( scope:Scope )->Cmd
      context = context.resolve( scope ).require_value
      if (property_info.type.is_compound)
        return CmdWriteProperty( t, context.cloned, property_info,
          CmdAccess( t,
                     CmdReadProperty(t,context,property_info),
                     "operator+",
                     CmdLiteralInt32(t,delta)
          ) ).resolve( scope )
      endIf
      return this

    method type->Type
      return null

endClass


class CmdAdjustGlobal : Cmd
  PROPERTIES
    global_info : Property
    delta         : Int32

  METHODS
    method init( t, global_info, delta )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdAdjustGlobal( t, global_info, delta )

    method resolve( scope:Scope )->Cmd
      if (global_info.type.is_compound)
        return CmdWriteGlobal( t, global_info,
          CmdAccess( t,
                     CmdReadGlobal(t,global_info),
                     "operator+",
                     CmdLiteralInt32(t,delta)
          ) ).resolve( scope )
      endIf
      return this

    method type->Type
      return null

endClass


#------------------------------------------------------------------------------
# ModifyAndAssign
#------------------------------------------------------------------------------
class CmdModifyAndAssign : Cmd
  PROPERTIES
    target    : Cmd
    op        : TokenType
    new_value : Cmd

  METHODS
    method init( t, target, op, new_value )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdModifyAndAssign( t, target.cloned( clone_args, new_t ), op, new_value.cloned( clone_args, new_t ) )

    method is_scoped_read_access->Logical
      return true

    method resolve( scope:Scope )->Cmd
      return target.resolve_modify_and_assign( scope, op, new_value )
endClass

class CmdResolvedModifyAndAssign : Cmd
  PROPERTIES
    op         : TokenType
    new_value  : Cmd

  METHODS
    method is_scoped_read_access->Logical
      return true

    method symbol->String
      if (op is TokenType.symbol_tilde_equals) return "^="
      return op->String

endClass

class CmdModifyAndAssignLocal : CmdResolvedModifyAndAssign
  PROPERTIES
    local_info : Local

  METHODS
    method init( t, local_info, op, new_value )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      local task_args = (clone_args as TaskArgs)
      if (task_args)
        return CmdModifyAndAssign( t, CmdAccess(t,CmdThisContext(t,task_args.task_type),"$_$"(local_info.name,local_info.index)), op, new_value.cloned(task_args) )
      else
        return CmdModifyAndAssignLocal( t, local_info, op, new_value.cloned( clone_args, new_t ) )
      endIf

    method is_scoped_read_access->Logical
      return true

    method resolve( scope:Scope )->Cmd
      local m_name = "operator" + op->String
      if (local_info.type.is_reference)
        if (local_info.type.method_lookup_by_name[m_name])
          return CmdAccess( t, CmdReadLocal(t,local_info), m_name, new_value ).resolve( scope )
        else
          new_value = new_value.resolve( scope ).require_value
          m_name = m_name.leftmost(-1)  # operator+= -> operator+
          if (local_info.type.method_lookup_by_name[m_name])
            return CmdWriteLocal( t, local_info,
            CmdAccess( t, CmdReadLocal(t,local_info), m_name, new_value ) ).resolve( scope )
          elseIf (local_info.type.global_method_lookup_by_name[m_name])
            return CmdWriteLocal( t, local_info,
              CmdAccess( t, CmdAccess(t,local_info.type.name), m_name,
                CmdArgs( CmdReadLocal(t,local_info), new_value ) ) ).resolve( scope )
          elseIf (new_value.type.global_method_lookup_by_name[m_name])
            return CmdWriteLocal( t, local_info,
                CmdAccess( t, CmdAccess(t,new_value.type.name), m_name,
                CmdArgs( CmdReadLocal(t,local_info), new_value ) ) ).resolve( scope )
          else
            local arg_type = new_value.require_type
            throw t.error( "No suitable operator method found; type $ implements neither $()($), $=($), nor global method $()(2)." (local_info.type,m_name,arg_type.name,m_name,arg_type.name,m_name) )
          endIf
        endIf
      elseIf (local_info.type.is_compound)
        return CmdWriteLocal( t, local_info,
            CmdAccess( t, CmdReadLocal(t,local_info), m_name.leftmost(-1), new_value ) ).resolve( scope )
      endIf

      which (op)
        case TokenType.symbol_caret_equals
          #if (RogueC.compile_targets["C++"])
          return CmdWriteLocal( t, local_info, CmdPower(t,CmdReadLocal(t,local_info),new_value) ).resolve( scope )

        case TokenType.symbol_percent_equals
          # Mod has be be expanded because Rogue uses a special mod function
          #if (RogueC.compile_targets["C++"])
          return CmdWriteLocal( t, local_info, CmdMod(t,CmdReadLocal(t,local_info),new_value) ).resolve( scope )

        case TokenType.symbol_dot_equals
          local access = new_value as CmdAccess
          if (not access) throw new_value.t.error( "Property or method name expected." )
          if (access.context) throw access.t.error( "Property or method name expected - '.=' cannot be used with a chain of references." )
          access.context = CmdReadLocal( t, local_info )
          return CmdWriteLocal( t, local_info, access ).resolve( scope )
      endWhich

      new_value = new_value.resolve( scope ).cast_to( local_info.type, scope ).resolve( scope )
      return this

    method type->Type
      return local_info.type
endClass


class CmdModifyAndAssignGlobal : CmdResolvedModifyAndAssign
  PROPERTIES
    global_info : Property

  METHODS
    method init( t, global_info, op, new_value )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdModifyAndAssignGlobal( t, global_info, op, new_value.cloned( clone_args, new_t ) )

    method resolve( scope:Scope )->Cmd
      local m_name = "operator" + op->String
      if (global_info.type.is_reference)
        if (global_info.type.method_lookup_by_name[m_name])
          return CmdAccess( t, CmdReadGlobal(t,global_info), m_name, new_value ).resolve( scope )
        else
          new_value = new_value.resolve( scope ).require_value
          m_name = m_name.leftmost(-1)  # operator+= -> operator+
          if (global_info.type.method_lookup_by_name[m_name])
            return CmdWriteGlobal( t, global_info,
              CmdAccess(t, CmdReadGlobal(t,global_info), m_name, new_value) ).resolve( scope )
          elseIf (global_info.type.global_method_lookup_by_name[m_name])
            return CmdWriteGlobal( t, global_info,
              CmdAccess( t, CmdAccess(t,global_info.type.name), m_name,
              CmdArgs( CmdReadGlobal(t,global_info), new_value ) ) ).resolve( scope )
          elseIf (new_value.type.global_method_lookup_by_name[m_name])
            return CmdWriteGlobal( t, global_info,
              CmdAccess( t, CmdAccess(t,new_value.type.name), m_name,
              CmdArgs( CmdReadGlobal(t,global_info), new_value ) ) ).resolve( scope )
          else
            local arg_type = new_value.type.name
            throw t.error( "No suitable operator method found; type $ implements neither $()($) nor $=($)." (global_info.type,m_name,arg_type,m_name,arg_type) )
          endIf
        endIf

      elseIf (global_info.type.is_compound)
        return CmdWriteGlobal( t, global_info,
          CmdAccess( t, CmdReadGlobal(t,global_info), m_name.leftmost(-1), new_value ) ).resolve( scope )
      endIf

      which (op)
        case TokenType.symbol_caret_equals
          #if (RogueC.compile_targets["C++"])
          return CmdWriteGlobal( t, global_info, CmdPower(t,CmdReadGlobal(t,global_info),new_value) ).resolve( scope )

        case TokenType.symbol_percent_equals
          # Mod has be be expanded because Rogue uses a special mod function
          #if (RogueC.compile_targets["C++"])
          return CmdWriteGlobal( t, global_info, CmdMod(t,CmdReadGlobal(t,global_info),new_value) ).resolve( scope )

        case TokenType.symbol_dot_equals
          local access = new_value as CmdAccess
          if (not access) throw new_value.t.error( "Property or method name expected." )
          if (access.context) throw access.t.error( "Property or method name expected - '.=' cannot be used with a chain of references." )
          access.context = CmdReadGlobal( t, global_info )
          return CmdWriteGlobal( t, global_info, access ).resolve( scope )
      endWhich

      new_value = new_value.resolve(scope).cast_to( global_info.type, scope ).resolve( scope )
      return this

    method type->Type
      return global_info.type
endClass

class CmdModifyAndAssignProperty : CmdResolvedModifyAndAssign
  PROPERTIES
    context       : Cmd
    property_info : Property

  METHODS
    method init( t, context, property_info, op, new_value )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdModifyAndAssignProperty( t, context.cloned( clone_args, new_t ), property_info, op, new_value.cloned( clone_args, new_t ) )

    method resolve( scope:Scope )->Cmd
      local m_name = "operator" + op->String
      if (property_info.type.is_reference)
        if (property_info.type.method_lookup_by_name[m_name])
          return CmdAccess( t, CmdReadProperty(t,context,property_info), m_name, new_value ).resolve( scope )
        else
          m_name = m_name.leftmost(-1)  # operator+= -> operator+
          new_value = new_value.resolve( scope ).require_value
          if (property_info.type.method_lookup_by_name[m_name])
            return CmdWriteProperty( t, context, property_info,
            CmdAccess(t, CmdReadProperty(t,clone(context),property_info), m_name, new_value) ).resolve( scope )
          elseIf (property_info.type.has_global_method_named(m_name))
            return CmdWriteProperty( t, context, property_info,
            CmdAccess(t, CmdAccess(t,property_info.type.name), m_name, CmdArgs(CmdReadProperty(t,clone(context),property_info), new_value)) ).resolve( scope )
          elseIf (new_value.type.has_global_method_named(m_name))
            return CmdWriteProperty( t, context, property_info,
            CmdAccess(t, CmdAccess(t,new_value.type.name), m_name, CmdArgs(CmdReadProperty(t,clone(context),property_info), new_value)) ).resolve( scope )
          else
            local arg_type = new_value.type.name
            throw t.error( "No suitable operator method found; type $ implements neither $()($) nor $=($)." (property_info.type,m_name,arg_type,m_name,arg_type) )
          endIf
        endIf

      elseIf (property_info.type.is_compound)
        return CmdWriteProperty( t, clone(context), property_info,
          CmdAccess( t, CmdReadProperty(t,context,property_info), m_name.leftmost(-1), new_value ) ).resolve( scope )
      endIf

      which (op)
        case TokenType.symbol_caret_equals
          #if (RogueC.compile_targets["C++"])
          return CmdWriteProperty( t, context, property_info, CmdPower(t,CmdReadProperty(t,clone(context),property_info),new_value) ).resolve( scope )

        case TokenType.symbol_percent_equals
          # Mod has be be expanded because Rogue uses a special mod function
          #if (RogueC.compile_targets["C++"])
          return CmdWriteProperty( t, context, property_info, CmdMod(t,CmdReadProperty(t,clone(context),property_info),new_value) ).resolve( scope )

        case TokenType.symbol_dot_equals
          local access = new_value as CmdAccess
          if (not access) throw new_value.t.error( "Property or method name expected." )
          if (access.context) throw access.t.error( "Property or method name expected - '.=' cannot be used with a chain of references." )
          access.context = CmdReadProperty( t, clone(context), property_info )
          return CmdWriteProperty( t, context, property_info, access ).resolve( scope )
      endWhich

      context = context.resolve(scope).require_value
      new_value = new_value.resolve(scope).cast_to( property_info.type, scope ).resolve( scope )
      return this

    method type->Type
      return property_info.type
endClass

#------------------------------------------------------------------------------
# Arrays
#------------------------------------------------------------------------------
class CmdCreateArray : Cmd
  PROPERTIES
    array_type   : Type
    count_cmd    : Cmd

  METHODS
    method init( t, array_type, args:CmdArgs )
      if (args is null or args.count != 1)
        throw t.error( "Array count expected." )
      endIf
      count_cmd = args.first

    method init( t, array_type, count_cmd )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCreateArray( t, array_type, count_cmd.cloned( clone_args, new_t ) )

    method resolve( scope:Scope )->Cmd
      array_type.organize(scope)
      count_cmd = count_cmd.resolve(scope).require_integer
      return this

    method type->Type
      return array_type
endClass

class CmdReadArrayElement : Cmd
  PROPERTIES
    context    : Cmd
    array_type : Type
    index      : Cmd

  METHODS
    method init( t, context, index )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      local result = CmdReadArrayElement( t, context.cloned( clone_args, new_t ), index.cloned( clone_args, new_t ) )
      result.array_type = array_type
      return result

    method resolve( scope:Scope )->Cmd
      context = context.resolve(scope)
      array_type = context.require_type
      index = index.resolve(scope).require_integer
      return this

    method resolve_adjust( scope:Scope, delta:Int32 )->Cmd
      return CmdWriteArrayElement( t, context, index.cloned, CmdAdd(t,this,CmdLiteralInt32(t,delta)) ).resolve( scope )

    method to->String
      return "CmdReadArrayElement($[$])" (context,index)

    method type->Type
      return array_type.element_type
endClass

class CmdReadArrayCount : Cmd
  PROPERTIES
    context      : Cmd
    array_type   : Type

  METHODS
    method init( t, context )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdReadArrayCount( t, context.cloned( clone_args, new_t ) )

    method resolve( scope:Scope )->Cmd
      if (array_type) return this

      context = context.resolve(scope)
      array_type = context.require_type
      return this

    method type->Type
      return Program.type_Int32
endClass

class CmdWriteArrayElement : Cmd
  PROPERTIES
    context    : Cmd
    array_type : Type
    index      : Cmd
    new_value  : Cmd

  METHODS
    method init( t, context, index, new_value )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdWriteArrayElement( t, context.cloned( clone_args, new_t ), index.cloned( clone_args, new_t ), new_value.cloned( clone_args, new_t ) )

    method resolve( scope:Scope )->Cmd
      if (array_type) return this

      context = context.resolve(scope)
      array_type = context.require_type
      index = index.resolve(scope).require_integer
      new_value = new_value.resolve( scope ).require_value.cast_to( array_type.element_type, scope ).resolve( scope )
      return this

    method type->Type
      return array_type.element_type
endClass
}#

#------------------------------------------------------------------------------
# Type Checks and Conversions
#------------------------------------------------------------------------------
class CmdTypeOperator : Cmd
  PROPERTIES
    operand     : Cmd
    target_type : String # Type *name*

  METHODS
    method init( t, operand, target_type )
endClass

#{
class CmdCastToType : CmdTypeOperator
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCastToType( t, operand.cloned( clone_args, new_t ), target_type )

    method resolve( scope:Scope )->Cmd
      operand = operand.resolve( scope )
      target_type.organize(scope)
      if (operand.require_type is target_type) return operand
      return this
endClass
}#

class CmdConvertToType : CmdTypeOperator
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdConvertToType( t, operand.cloned( clone_args, new_t ), target_type )

    method eval( scope:Scope )->Value
      local type = TypeInfo.get(target_type)
      if (type is null) throw t.error("Unknown type '$'." (target_type))

      local v = operand.eval( scope )

      if (v.is_null or (v.is_object and v->Object is null))
        if (type.is_reference) return null
        throw t.error("Can't convert null reference to type '$'." (target_type))
      elseIf (v.is_object and (v->Object instanceOf RoseProxy))
        local o = v->Object->RoseProxy.o
        forEach (m in o.type_info.method_info("to_" + target_type))
          if ((m.param_count == 0) and (m.return_type is type))
            return o.introspector.call("to_" + target_type, @[])
          endIf
        endForEach
        throw t.error("No conversion from type '$' to '$'." (o.type_name, target_type))
      elseIf (not v.is_object)
        local o = v
        forEach (m in o.type_info.method_info("to_" + target_type))
          if ((m.param_count == 0) and (m.return_type is type))
            return o.introspector.call("to_" + target_type, @[])
          endIf
        endForEach
        throw t.error("No conversion from type '$' to '$'." (o.type_name, target_type))
      endIf

      throw t.error("No conversion from type '$' to '$'." (v.type_name, target_type))

    method to->String
      return "CmdConvertToType($,$)" (operand,target_type)
endClass

#{
class CmdAs : CmdTypeOperator
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdAs( t, operand.cloned( clone_args, new_t ), target_type )

    method resolve( scope:Scope )->Cmd
      operand = operand.resolve( scope )
      local operand_type = operand.require_type
      target_type.organize(scope)
      if (operand_type is target_type) return operand

      if (not (operand_type.is_reference and target_type.is_reference))
        return target_type.create_default_value( t )
      endIf
      return this
endClass
}#

class CmdInstanceOf : CmdTypeOperator
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdInstanceOf( t, operand.cloned( clone_args, new_t ), target_type )

    method eval( scope:Scope )->Value
      local v = operand.eval( scope )

      if (v.is_logical)
        throw t.error( "Illegal logical operand for instanceOf - note that correct syntax is '<expression> not instanceOf Type' rather than 'not <expression> instanceOf Type' instead." )
      elseIf (not CmdIsReference.is_reference(v))
        throw t.error( "Illegal 'instanceOf' on non-reference." )
      endIf

      require v->Object instanceOf RoseObject

      if (v->Object instanceOf RoseProxy)
        local type = TypeInfo.get(target_type)
        if (type is null) throw t.error("Unknown type '$'." (target_type))
        local o = (v->Object as RoseProxy).o
        if (o is null) return false
        return o.type_info.instance_of(type)
      elseIf (v->Object instanceOf RoseObject)
        throw t.error( "'instanceOf' not yet implemented for Rose objects" )
      else
        throw t.error( "'instanceOf' on unexpected reference type '$'" ((v->Object).type_name ) )
      endIf

      return false
endClass

class CmdIsReference( t, operand:Cmd ) : Cmd
  GLOBAL METHODS
    method is_reference (v:Value)->Logical
      if (v.is_object or v.is_null or v.is_list or v.is_table) return true
      return false

  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdIsReference( t, operand.cloned( clone_args, new_t ) )

    method eval( scope:Scope )->Value
      return is_reference(operand.eval(scope))
endClass

#{

#------------------------------------------------------------------------------
# Collections
#------------------------------------------------------------------------------
class CmdCreateList : Cmd
  PROPERTIES
    elements   : CmdArgs

  METHODS
    method init( t, elements )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCreateList( t, clone(elements,clone_args,new_t) )

    method implicit_type( scope:Scope )->Type
      if (elements.count == 0) return Program.get_type_reference( t, "ValueList" )

      local common_type = elements.first.implicit_type( scope )
      if (not common_type) return null

      forEach (arg in elements)
        local arg_type = arg.implicit_type( scope )
        if (arg_type is not common_type) return null
      endForEach

      return Program.get_type_reference( t, common_type.name + "[]" )

    method resolve( scope:Scope )->Cmd
      local list_type : Type

      elements.resolve( scope )
      if (not list_type and elements.count)
        local common_type = elements.first.type
        forEach (arg in elements)
          common_type = find_common_type( common_type, arg.type )
        endForEach
        list_type = Program.get_type_reference( t, common_type + "[]" )
        list_type.organize(scope)
      endIf

      if (list_type)
        local element_type = list_type.element_type
        forEach (index of elements)
          elements[index] = elements[index].resolve( scope ).cast_to( element_type, scope ).resolve( scope )
        endForEach
      endIf

      if (not list_type) throw t.error( "TODO: [] -> Property[]" )

      return CmdTypedLiteralList( t, list_type.name, elements ).resolve( scope )

endClass


#------------------------------------------------------------------------------
# Task-Related
#------------------------------------------------------------------------------
class CmdAwait : Cmd
  PROPERTIES
    expression     : Cmd
    statement_list : CmdStatementList
    result_var     : Local

  METHODS
    method init( t, expression, statement_list, result_var=null )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      local task_args = (clone_args as TaskArgs)
      if (task_args)
        throw t.error( "[INTERNAL] CmdAwait should have been converted to other commands before being adapted to a task." )
      else
        return CmdAwait( t, expression.cloned(task_args), statement_list.cloned(task_args), result_var )
      endIf

    method resolve( scope:Scope )->Cmd
      if (not scope.this_method.is_task_conversion)
        throw t.error( "The 'await' command can only be used in [task] methods and routines." )
      endIf

      expression = expression.resolve( scope )
      local task_type = expression.require_type
      local p_result = task_type.find_property( "result" )
      if (result_var)
        if (p_result)
          # Fix up local 'result' type to match task result type
          result_var.type = p_result.type
        else
          throw expression.t.error( "Called task does not produce a result." )
        endIf
      endIf

      local task_var = scope.this_method.add_local( t, Program.create_unique_id )
      task_var.initial_value = expression
      statement_list.add( CmdLocalDeclaration(t, task_var) )
      statement_list.add( CmdAssign( t, CmdAccess(t,CmdReadLocal(t,task_var),"has_result"), CmdLiteralLogical(t,false) ) )

      local condition = CmdAccess(t,CmdReadLocal(t,task_var),"execute") : Cmd
      condition = CmdLogicalOr( t, condition, CmdLogicalNot(t,CmdAccess(t,CmdReadLocal(t,task_var),"has_result")) )
      local cmd_while = CmdGenericLoop( t, CmdControlStructure.type_while, condition )
      cmd_while.statements.add( CmdYield(t,null) )
      statement_list.add( cmd_while )

      if (result_var)
        statement_list.add( CmdWriteLocal(t, result_var, CmdReadProperty(t,CmdReadLocal(t,task_var),p_result)) )
      endIf

      statement_list.resolve( scope )
      return CmdBlock( t, statement_list ).resolve( scope )
endClass

class CmdYield : Cmd
  PROPERTIES
    return_value : Cmd

  METHODS
    method init( t, return_value )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      local task_args = (clone_args as TaskArgs)
      if (task_args)
        task_args.add_yield( t, clone(return_value,clone_args,new_t) )
        return null
      else
        return CmdYield( t, clone(return_value,clone_args,new_t) )
      endIf

    method resolve( scope:Scope )->Cmd
      if (not scope.this_method.is_task_conversion)
        throw t.error( "The 'yield' statement can only be used in [task] methods and routines." )
      endIf

      if (return_value) return_value = return_value.resolve( scope ).require_value

      forEach (control_structure in scope.control_stack)
        control_structure.contains_yield = true
      endForEach

      return this
endClass

class CmdTaskControlSection
  PROPERTIES
    ip : Int32
    statements = CmdStatementList()

  METHODS
    method init( ip )
endClass

class CmdTaskControl : Cmd
  PROPERTIES
    sections = CmdTaskControlSection[]
    current_section : CmdTaskControlSection

  METHODS
    method init( t )
      current_section = CmdTaskControlSection(1)
      sections.add( current_section )

    method add( cmd:Cmd )->CmdTaskControl
      current_section.statements.add( cmd )
      return this

    method requires_semicolon->Logical
      return false

    method resolve( scope:Scope )->Cmd
      forEach (section in sections)
        section.statements.resolve( scope )
      endForEach
      return this

endClass


#------------------------------------------------------------------------------
# Callbacks
#------------------------------------------------------------------------------
class CmdCreateCallback( t, context:Cmd, name:String, signature:String, return_type:Type ) : Cmd
  METHODS
    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdCreateCallback
      if (new_t) t = new_t
      return CmdCreateCallback( t, context.cloned( clone_args, new_t ), name, signature, return_type )

    method resolve( scope:Scope )->Cmd
      if (name == "to" and return_type) name = "to_" + return_type.name

      context = context.resolve( scope )
      local context_type = context.require_type
      context_type.organize(scope)

      local m = context_type.find_method( name + signature )
      if (not m)
        local methods = context_type.method_lookup_by_name[ name ]
        if (not methods) methods = context_type.global_method_lookup_by_name[ name ]
        if (not methods)        throw t.error( "No such method '$' exists in type $." (name,context_type.name) )
        if (methods.count != 1) throw t.error( "Multiple candidates match ambiguous reference to '$'; add qualifiying parameter types." (name) )
        m = methods.first
      endIf

      local parameter_types : Type[]
      if (m.parameters.count)
        parameter_types = Type[]
        forEach (p in m.parameters) parameter_types.add( p.type )
      endIf

      local callback_type_name = context_type.name + "." + name + Program.get_callback_type_signature(parameter_types)
      local callback_type = Program.get_type_reference( t, callback_type_name )

      if (not callback_type.defined)
        callback_type.defined = true
        callback_type.attributes.add( Attribute.is_class )

        local base_type = Program.get_callback_type_reference( t, parameter_types, m.return_type )
        callback_type.base_types.add( base_type )
        base_type.extended_types.add( callback_type )

        local m_call = callback_type.add_method( t, "call" )
        local args = CmdArgs()
        if (parameter_types)
          forEach (i of parameter_types)
            local param_name = "param" + (i+1)
            m_call.add_parameter( t, param_name, parameter_types[i] )
            args.add( CmdAccess(t,param_name) )
          endForEach
        endIf

        local cmd : Cmd
        if (m.is_global)
          callback_type.attributes.add( Attribute.is_singleton )
          cmd = CmdAccess( t, CmdAccess(t,context_type.name), name, args )
        else
          callback_type.add_property( t, "context", context_type )
          local m_init = callback_type.add_method( t, "init" )
          m_init.add_parameter( t, "context" )
          cmd = CmdAccess( t, CmdAccess(t,"context"), name, args )
        endIf

        if (m.return_type)
          m_call.return_type = m.return_type
          cmd = CmdReturn( t, cmd )
        endIf

        m_call.statements.add( cmd )
      endIf

      if (m.is_global)
        return CmdReadSingleton( t, callback_type ).resolve( scope )
      else
        return CmdAccess( t, callback_type_name, CmdArgs(context) ).resolve( scope )
      endIf

endClass


class CmdCreateFunction( t, parameters:FnParam[], return_type:Type, with_args:FnArg[], statements:CmdStatementList, tokens:Token[], is_generic:Logical, query_cmd=null:Cmd ) : Cmd
  METHODS
    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdCreateFunction
      if (new_t) t = new_t
      local args2 : FnArg[]
      if (with_args)
        args2 = FnArg[]
        forEach (arg in with_args)
          args2.add( FnArg( arg.name, arg.value.cloned( clone_args, new_t ) ).set_type( arg.type ) )
        endForEach
      endIf
      return CmdCreateFunction( t, parameters, return_type, args2, clone(statements,clone_args), tokens, is_generic, clone(query_cmd,clone_args,new_t) )

    method implicit_type( scope:Scope )->Type
      if (is_generic_function) return null

      local parameter_types : Type[]
      if (parameters and parameters.count)
        parameter_types = Type[]
        forEach (param in parameters) parameter_types.add( param.type )
      endIf

      return Program.get_callback_type_reference( t, parameter_types, return_type )

    method is_generic_function->Logical
      return is_generic

    method is_scoped_read_access->Logical
      return true

    method resolve( scope:Scope )->Cmd
      if (is_generic)
        if (query_cmd)
          QueryToGenericFunctionConversionVisitor.convert( query_cmd, this )
          query_cmd = null
        endIf
        return this
      endIf

      local parameter_types : Type[]
      if (parameters and parameters.count)
        parameter_types = Type[]
        forEach (param in parameters) parameter_types.add( param.type )
      endIf

      local fn_name = "Function_" + Program.next_unique_integer
      local fn_type = Program.get_type_reference( t, fn_name )

      fn_type.defined = true
      fn_type.attributes.add( Attribute.is_class )

      local base_type = Program.get_callback_type_reference( t, parameter_types, return_type )
      fn_type.base_types.add( base_type )
      base_type.extended_types.add( fn_type )

      local m_call = fn_type.add_method( t, "call" )
      if (parameters)
        forEach (param in parameters)
          m_call.add_parameter( t, param.name, param.type )
        endForEach
      endIf

      m_call.return_type = return_type
      if (statements)
        m_call.statements = statements
      else
        local parser = Parser( tokens )
        parser.this_type = fn_type
        parser.this_method = m_call
        parser.parse_multi_line_statements( m_call.statements )
      endIf

      m_call.statements.dispatch( UpdateThisTypeVisitor(fn_type,m_call) )

      if (with_args)
        local m_init = fn_type.add_method( t, "init" )
        local create_args = CmdArgs()
        forEach (fn_arg in with_args)
          local arg = fn_arg.value.resolve( scope ).require_value
          create_args.add( arg )
          fn_type.add_property( fn_arg.value.t, fn_arg.name, arg.type )
          m_init.add_parameter( fn_arg.value.t, fn_arg.name )  # auto-initializing
        endForEach

        return CmdAccess( t, fn_name, create_args ).resolve( scope )

      else
        fn_type.attributes.add( Attribute.is_singleton )
        return CmdReadSingleton( t, fn_type ).resolve( scope )
      endIf

    method type->Type
      if (is_generic_function)
        # Some type is necessary for generic funtcions to avoid triggering a "value expected" error
        # before being able to match the generic function to a method's expected callback type.
        return Program.type_Object
      else
        return implicit_type( null )
      endIf

endClass

#------------------------------------------------------------------------------
# Optional
#------------------------------------------------------------------------------
class CmdCreateOptionalValue : Cmd
  PROPERTIES
    of_type : Type
    value   : Cmd

  METHODS
    method init( t, of_type, value=null )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCreateOptionalValue( t, of_type, clone(value,clone_args,new_t) )

    method resolve( scope:Scope )->Cmd
      of_type.organize(scope)
      if (value) value = value.resolve( scope )
      return this

    method type->Type
      return of_type

endClass
}#


#------------------------------------------------------------------------------
# Miscellaneous
#------------------------------------------------------------------------------
class CmdAssert : Cmd
  PROPERTIES
    condition  : Cmd
    message    : Cmd
    error      : Cmd

  METHODS
    method init( t, condition, message )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdAssert
      if (new_t) t = new_t
      return CmdAssert( t, condition.cloned( clone_args, new_t ), message.cloned( clone_args, new_t ) )

    method is_scoped_read_access->Logical
      return true

    method eval( scope:Scope )->Value
      local cond = condition.eval(scope)
$if (DEBUG)
      if (not cond?)
        local msg = "Assertion not met"
        if (message)
          local m = message.eval(scope)
          if (m) msg += ": " + m
        endIf
        throw t.error(msg)
      endIf
$endIf
      return cond
endClass

class CmdRequire : CmdAssert
  PROPERTIES
    condition  : Cmd
    message    : Cmd
    error      : Cmd

  METHODS
    method init( t, condition, message )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdRequire
      if (new_t) t = new_t
      return CmdRequire( t, condition.cloned( clone_args, new_t ), message.cloned( clone_args, new_t ) )

    method is_scoped_read_access->Logical
      return true

    method eval( scope:Scope )->Value
      local cond = condition.eval(scope)
      if (not cond?)
        local msg = "Requirement not met"
        if (message)
          local m = message.eval(scope)
          if (m) msg += ": " + m
        endIf
        throw t.error(msg)
      endIf
      return cond
endClass

#{
class CmdTrace : Cmd
  PROPERTIES
    info : Cmd

  METHODS
    method init( t, info )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdTrace
      if (new_t) t = new_t
      return CmdTrace( t, clone(info,clone_args,new_t) )

    method resolve( scope:Scope )->Cmd
      return CmdAccess( t, CmdAccess(t,"Global"), "println", CmdArgs(info) ).resolve( scope )

endClass

class CmdLabel : Cmd
  PROPERTIES
    name       : String
    statements : CmdStatementList
    is_referenced : Logical

  METHODS
    method init( t, name, statements=CmdStatementList() )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdLabel
      if (new_t) t = new_t
      local result = CmdLabel( t, name, statements.cloned( clone_args, new_t ) )
      if (clone_args) clone_args.register_label( result )
      return result

    method generates_output->Logical
      forEach (statement in statements)
        if (statement.generates_output) return true
      endForEach
      return false

    method requires_semicolon->Logical
      return false

    method resolve( scope:Scope )->Cmd
      statements.resolve( scope )
      return this

    method to->String
      return ''CmdLabel($)'' (name)

endClass
}#


class CmdNoAction : Cmd
  METHODS
    method init( t )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdNoAction
      if (new_t) t = new_t
      return CmdNoAction( t )

    method add_to( statements:CmdStatementList )
      noAction

    method generates_output->Logical
      return false

    method requires_semicolon->Logical
      return false

    method eval( scope:Scope )->Value
      return UndefinedValue

endClass

class CmdTypedLiteralList : Cmd
  PROPERTIES
    list_type_name : String
    elements       : CmdArgs

  METHODS
    method init( t, list_type_name, elements=CmdArgs() )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdTypedLiteralList
      if (new_t) t = new_t
      return CmdTypedLiteralList( t, list_type_name, elements.cloned( clone_args, new_t ) )

    method add( element:Cmd )->CmdTypedLiteralList
      elements.add( element )
      return this

    method eval (scope:Scope)->Value
      local v = ValueList()
      v.add_all(elements.evaled(scope))
      return v

#{
    method resolve( scope:Scope )->Cmd
      local list_type = Program.get_type_reference( t, list_type_name )
      local list_var = scope.this_method.add_local( t, Program.create_unique_id, list_type )
      list_var.initial_value = CmdAccess( t, list_type_name, CmdArgs(CmdLiteralInt32(t,elements.count)) )
      local declaration = CmdLocalDeclaration( t, list_var )
      scope.this_body.add( declaration.resolve(scope) )

      local init_block = CmdBlock( t )
      scope.this_body.add( init_block )

      if (list_type_name == "Byte[]")
        elements.resolve( scope )
        contingent
          necessary ((forEach in elements).is_literal_number)
        satisfied
          # Convert Byte[](a,b,c) to Byte[]("AABBCC")
          local bytes = Byte[]( elements.count )
          bytes.add( (forEach in elements)->Byte )

          init_block.statements.add(
              CmdAccess( t,CmdAccess(t,list_var.name), "add",
                  CmdArgs( CmdLiteralString(t,bytes.to_hex_string) ) ) )
          init_block = init_block.resolve( scope )

          local result = CmdAccess( t, list_var ).resolve( scope )
          return result
        endContingent
      endIf

      forEach (element in elements)
        local item = CmdAccess( t,CmdAccess(t,list_var.name), "add", element )
        init_block.statements.add( item )
      endForEach
      init_block = init_block.resolve( scope )

      local result = CmdAccess( t, list_var ).resolve( scope )
      return result
}#
endClass


class CmdTypedLiteralTable : Cmd
  PROPERTIES
    table_type_name : String
    keys            : CmdArgs
    values          : CmdArgs

  METHODS
    method init( t, table_type_name, keys=CmdArgs(), values=CmdArgs() )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdTypedLiteralTable
      if (new_t) t = new_t
      return CmdTypedLiteralTable( t, table_type_name, keys.cloned( clone_args, new_t ), values.cloned( clone_args, new_t ) )

    method add( key:Cmd, value:Cmd )->CmdTypedLiteralTable
      keys.add( key )
      values.add( value )
      return this

    method add_key( key:Cmd )->CmdTypedLiteralTable
      keys.add( key )
      return this

    method add_value( value:Cmd )->CmdTypedLiteralTable
      values.add( value )
      return this


    method eval(scope:Scope)->Value
      local r = ValueTable()
      local ks = keys.evaled(scope)
      local vs = values.evaled(scope)
      forEach (i in 0..<ks.count)
        r.set(ks[i]->String, vs[i])
      endForEach
      return r

#{
    method resolve( scope:Scope )->Cmd
      local table_var = scope.this_method.add_local( t, Program.create_unique_id, type )
      table_var.initial_value = CmdAccess( t, table_type_name, CmdArgs() )
      scope.this_body.add( CmdLocalDeclaration(t,table_var).resolve(scope) )

      local init_block = CmdBlock( t )
      scope.this_body.add( init_block )

      forEach (key at index in keys)
        local item = CmdAccess( t,CmdAccess(t,table_var.name), "set", CmdArgs(key,values[index]) )
        init_block.statements.add( item )
      endForEach
      init_block = init_block.resolve( scope )

      return CmdAccess( t, table_var ).resolve( scope )
}#
endClass


#{
class CmdSelect : Cmd
  PROPERTIES
    local_info : Local
    expression : Cmd
    cases      : CmdSelectCase[]
    value_type : Type
    undeclared_locals : Local[]

  METHODS
    method init( t, local_info=null, expression=null, cases=CmdSelectCase[] )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdSelect
      if (new_t) t = new_t
      local result = CmdSelect( t, local_info, clone(expression,clone_args,new_t), CmdSelectCase[](cases.count) )
      forEach (c in cases) result.cases.add( c.cloned( clone_args, new_t ) )
      return result

    method implicit_type( scope:Scope )->Type
      local common_type : Type
      forEach (c in cases)
        local case_type = c.implicit_type( scope )
        if (not common_type) common_type = case_type
        elseIf (common_type is not case_type) return null
      endForEach
      return common_type

    method resolve( scope:Scope )->Cmd
      if (undeclared_locals)
        scope.this_method.add_local( forEach in undeclared_locals )
        undeclared_locals = null
      endIf

      if (value_type) return this

      if (not cases.count)
        throw t.error( "Selection list cannot be empty." )
      endIf

      forEach (c in cases)
        c.resolve( scope )
        local case_type = c.type
        value_type = must_find_common_type( value_type, case_type )
      endForEach

      forEach (c in cases)
        c.cast_value( value_type, scope )
      endForEach

      if (expression)
        expression = expression.resolve( scope )
        local expr_type = expression.require_type
        forEach (c in cases)
          c.cast_conditions( expr_type, scope )
        endForEach
      endIf

      return this

    method type->Type
      return value_type
endClass

class CmdSelectCase : Cmd
  PROPERTIES
    conditions : Cmd[]
    value      : Cmd
    local_info : Local
    condition_is_value : Logical

  METHODS
    method init( t, conditions=Cmd[](1), value=null, local_info=null )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdSelectCase
      if (new_t) t = new_t
      local result = CmdSelectCase( t, null, clone(value,clone_args,new_t), local_info )
      result.conditions = Cmd[]( conditions.count )
      forEach (c in conditions) result.conditions.add( c.cloned( clone_args, new_t ) )
      result.condition_is_value = condition_is_value
      return result

    method cast_conditions( to_type:Type, scope:Scope )
      forEach (i of conditions)
        conditions[i] = conditions[i].cast_to( to_type, scope ).resolve( scope ).require_value
      endForEach

    method cast_value( to_type:Type, scope:Scope )
      # Value has been resolved; cast to final type
      local value_type = value.type
      if (value_type.is_optional and not to_type.is_optional)
        value = CmdAccess(value.t,value,"value").resolve( scope )
      endIf
      value = value.cast_to( to_type, scope ).resolve( scope ).require_value

    method implicit_type( scope:Scope )->Type
      return select { value:value.implicit_type(scope) || null }

    method resolve( scope:Scope )->Cmd
      forEach (condition at i in conditions)
        condition = conditions[i].resolve( scope ).require_value
        if (condition.type.is_optional)
          condition = CmdAccess(condition.t,condition,"exists").resolve( scope )
        endIf
        conditions[i] = condition
      endForEach

      if (not value) value = conditions.first.cloned
      value = value.resolve( scope ).require_value

      if (value.type.is_optional and condition_is_value)
        value = CmdAccess(value.t,value,"value").resolve( scope )
      endIf

      return this

    method type->Type
      return value.type
endClass


class CmdEnsure : Cmd
  PROPERTIES
    operand    : Cmd
    args       : CmdArgs
    named_args : CmdNamedArg[]

  METHODS
    method init( t, operand, args, named_args=null )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      local result = CmdEnsure( t, operand.cloned( clone_args, new_t ), clone(args,clone_args,new_t) )

      if (named_args)
        result.named_args = CmdNamedArg[]( named_args.count )
        forEach (named_arg in named_args) result.named_args.add( named_arg.cloned )
      endIf

      return result

    method implicit_type( scope:Scope )->Type
      return operand.implicit_type( scope )

    method is_scoped_read_access->Logical
      return true

    method resolve( scope:Scope )->Cmd
      local cmd_read = operand.cloned.resolve( scope ).require_value
      if (not cmd_read.type.is_reference) throw t.error( "'ensure' can only be used with reference-type variables." )

      local cmd_new = CmdAccess( t, cmd_read.type.name, args )
      cmd_new.named_args = named_args

      # We can convert this statement-level ensure into a simple 'if'.
      cmd_read = operand.cloned.resolve( scope ).require_value

      local cmd_if = CmdIf( t, CmdLogicalNot(t,cmd_read) )
      cmd_if.statements.add( CmdAssign( t, operand, cmd_new ) )

      return cmd_if.resolve( scope )

    method type->Type
      return null

endClass


class CmdImplicitAccess( t ) : Cmd
  # Null access signifies "this" access AKA query value
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdImplicitAccess( t )

    method convert_to_explicit_access->Cmd
      return CmdAccess( t, "value" )

    method resolve( scope:Scope )->Cmd
      throw t.error( "Illegal use of implicit access; can only be used as a query argument in a call." )
endClass


class CmdMetaMethodSignature( t ) : Cmd
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdMetaMethodSignature( t )

    method resolve( scope:Scope )->Cmd
      return CmdLiteralString( t, scope.this_method.signature ).resolve( scope )

    method type->Type
      return Program.type_String
endClass


class CmdTypeSelector( t, of_type:Type ) : Cmd
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdTypeSelector( t, of_type )

    method implicit_type->Type
      return of_type

    method resolve( scope:Scope )->Cmd
      of_type.organize( scope )
      return CmdAccess( t, CmdAccess(t,"TypeInfo"), "get", CmdArgs(CmdLiteralString(t,of_type)) ).resolve( scope )

    method type->Type
      return of_type
endClass


class CmdPrintln( t, standard=null:Cmd, no_parens=null:Cmd) : Cmd
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdPrintln( t, standard.cloned(clone_args,new_t), no_parens.cloned(clone_args,new_t) )

    method resolve( scope:Scope )->Cmd
      try
        return standard.resolve( scope )
      catch ( err:RogueError )
        return no_parens.resolve( scope )
      endTry
endClass

}#
